/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type std_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: i32 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<__mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = std_size_t;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx_new_allocator_difference_type = ::std::os::raw::c_long;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type ms_int32 = ::std::os::raw::c_int;
pub type ms_uint32 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyph_element {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct face_element {
    _unused: [u8; 0],
}
pub type ms_bitarray = *mut ms_uint32;
pub type ms_const_bitarray = *const ms_uint32;
#[doc = "This class allows inspection of the MapServer error stack."]
#[doc = "Instances of errorObj are created internally by MapServer as errors happen."]
#[doc = "Errors are managed as a chained list with the first item being the most recent error."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct errorObj {
    #[doc = "< MapServer error code such as :data:`MS_IMGERR`"]
    pub code: ::std::os::raw::c_int,
    #[doc = "< MapServer function in which the error was set"]
    pub routine: [::std::os::raw::c_char; 64usize],
    #[doc = "< Context-dependent error message"]
    pub message: [::std::os::raw::c_char; 2048usize],
    #[doc = "< :data:`MS_TRUE` or :data:`MS_FALSE` flag indicating if the error has been output"]
    pub isreported: ::std::os::raw::c_int,
    #[doc = "< Number of subsequent errors"]
    pub errorcount: ::std::os::raw::c_int,
    pub next: *mut errorObj,
    pub totalerrorcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_errorObj() {
    assert_eq!(
        ::std::mem::size_of::<errorObj>(),
        2144usize,
        concat!("Size of: ", stringify!(errorObj))
    );
    assert_eq!(
        ::std::mem::align_of::<errorObj>(),
        8usize,
        concat!("Alignment of ", stringify!(errorObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).routine as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).message as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).isreported as *const _ as usize },
        2116usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(isreported)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).errorcount as *const _ as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(errorcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).next as *const _ as usize },
        2128usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<errorObj>())).totalerrorcount as *const _ as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(errorObj),
            "::",
            stringify!(totalerrorcount)
        )
    );
}
extern "C" {
    #[doc = "Get the MapServer error object"]
    pub fn msGetErrorObj() -> *mut errorObj;
}
extern "C" {
    #[doc = "Clear the list of error objects"]
    pub fn msResetErrorList();
}
extern "C" {
    #[doc = "Returns a string containing MapServer version information, and details on what optional components"]
    #[doc = "are built in - the same report as produced by ``mapserv -v``"]
    pub fn msGetVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Returns the MapServer version number (x.y.z) as an integer (x*10000 + y*100 + z)"]
    #[doc = "e.g. V7.4.2 would return 70402"]
    pub fn msGetVersionInt() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return a string of all errors"]
    pub fn msGetErrorString(
        delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msRedactCredentials(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msSetError(
        code: ::std::os::raw::c_int,
        message: *const ::std::os::raw::c_char,
        routine: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn msWriteError(stream: *mut FILE);
}
extern "C" {
    pub fn msWriteErrorXML(stream: *mut FILE);
}
extern "C" {
    pub fn msGetErrorCodeString(code: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msAddErrorDisplayString(
        source: *mut ::std::os::raw::c_char,
        error: *mut errorObj,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteErrorImage(
        map: *mut mapObj,
        filename: *mut ::std::os::raw::c_char,
        blank: ::std::os::raw::c_int,
    );
}
pub const debugLevel_MS_DEBUGLEVEL_ERRORSONLY: debugLevel = 0;
pub const debugLevel_MS_DEBUGLEVEL_DEBUG: debugLevel = 1;
pub const debugLevel_MS_DEBUGLEVEL_TUNING: debugLevel = 2;
pub const debugLevel_MS_DEBUGLEVEL_V: debugLevel = 3;
pub const debugLevel_MS_DEBUGLEVEL_VV: debugLevel = 4;
pub const debugLevel_MS_DEBUGLEVEL_VVV: debugLevel = 5;
pub const debugLevel_MS_DEBUGLEVEL_DEVDEBUG: debugLevel = 20;
pub type debugLevel = ::std::os::raw::c_uint;
extern "C" {
    pub fn msDebug(pszFormat: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn msSetErrorFile(
        pszErrorFile: *const ::std::os::raw::c_char,
        pszRelToPath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCloseErrorFile();
}
extern "C" {
    pub fn msGetErrorFile() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msSetGlobalDebugLevel(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msGetGlobalDebugLevel() -> debugLevel;
}
extern "C" {
    pub fn msDebugInitFromEnv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDebugCleanup();
}
#[doc = "A rectObj represents a rectangle or bounding box."]
#[doc = "A rectObj may be a lone object or an attribute of another object and has no other associations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rectObj {
    #[doc = "< Minimum easting"]
    pub minx: f64,
    #[doc = "< Minimum northing"]
    pub miny: f64,
    #[doc = "< Maximum easting"]
    pub maxx: f64,
    #[doc = "< Maximum northing"]
    pub maxy: f64,
}
#[test]
fn bindgen_test_layout_rectObj() {
    assert_eq!(
        ::std::mem::size_of::<rectObj>(),
        32usize,
        concat!("Size of: ", stringify!(rectObj))
    );
    assert_eq!(
        ::std::mem::align_of::<rectObj>(),
        8usize,
        concat!("Alignment of ", stringify!(rectObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rectObj>())).minx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rectObj),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rectObj>())).miny as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rectObj),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rectObj>())).maxx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rectObj),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rectObj>())).maxy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rectObj),
            "::",
            stringify!(maxy)
        )
    );
}
#[doc = "A :class:`pointObj` has an x, y, z and m values."]
#[doc = "A :class:`pointObj` instance may be associated with a :class:`lineObj`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pointObj {
    #[doc = "< The x coordinate of the point"]
    pub x: f64,
    #[doc = "< The y coordinate of the point"]
    pub y: f64,
    #[doc = "< The z (height) coordinate of the point"]
    pub z: f64,
    #[doc = "< The m (measure) of the point, used for linear referencing"]
    pub m: f64,
}
#[test]
fn bindgen_test_layout_pointObj() {
    assert_eq!(
        ::std::mem::size_of::<pointObj>(),
        32usize,
        concat!("Size of: ", stringify!(pointObj))
    );
    assert_eq!(
        ::std::mem::align_of::<pointObj>(),
        8usize,
        concat!("Alignment of ", stringify!(pointObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pointObj>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pointObj),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pointObj>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pointObj),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pointObj>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pointObj),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pointObj>())).m as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pointObj),
            "::",
            stringify!(m)
        )
    );
}
#[doc = "A :class:`lineObj` is composed of one or more :class:`pointObj` instances"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lineObj {
    #[doc = "< Number of points in the line"]
    pub numpoints: ::std::os::raw::c_int,
    pub point: *mut pointObj,
}
#[test]
fn bindgen_test_layout_lineObj() {
    assert_eq!(
        ::std::mem::size_of::<lineObj>(),
        16usize,
        concat!("Size of: ", stringify!(lineObj))
    );
    assert_eq!(
        ::std::mem::align_of::<lineObj>(),
        8usize,
        concat!("Alignment of ", stringify!(lineObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lineObj>())).numpoints as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lineObj),
            "::",
            stringify!(numpoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lineObj>())).point as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lineObj),
            "::",
            stringify!(point)
        )
    );
}
#[doc = "Each feature of a layer's data is a :class:`shapeObj`. Each part of the shape is a closed :class:`lineObj`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shapeObj {
    pub line: *mut lineObj,
    pub values: *mut *mut ::std::os::raw::c_char,
    pub geometry: *mut ::std::os::raw::c_void,
    pub renderer_cache: *mut ::std::os::raw::c_void,
    #[doc = "< Number of parts"]
    pub numlines: ::std::os::raw::c_int,
    #[doc = "< Number of shape attributes"]
    pub numvalues: ::std::os::raw::c_int,
    #[doc = "< Bounding box of shape"]
    pub bounds: rectObj,
    #[doc = "< MS_SHAPE_POINT, MS_SHAPE_LINE, MS_SHAPE_POLYGON, or MS_SHAPE_NULL"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Feature index within the layer"]
    pub index: ::std::os::raw::c_long,
    #[doc = "< Index of tiled file for tile-indexed layers"]
    pub tileindex: ::std::os::raw::c_int,
    #[doc = "< The class index for features of a classified layer"]
    pub classindex: ::std::os::raw::c_int,
    #[doc = "< Shape annotation"]
    pub text: *mut ::std::os::raw::c_char,
    pub scratch: ::std::os::raw::c_int,
    #[doc = "< Index within a query result set"]
    pub resultindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_shapeObj() {
    assert_eq!(
        ::std::mem::size_of::<shapeObj>(),
        112usize,
        concat!("Size of: ", stringify!(shapeObj))
    );
    assert_eq!(
        ::std::mem::align_of::<shapeObj>(),
        8usize,
        concat!("Alignment of ", stringify!(shapeObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).geometry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(geometry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).renderer_cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(renderer_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).numlines as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(numlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).numvalues as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(numvalues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).bounds as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).index as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).tileindex as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(tileindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).classindex as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(classindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).text as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).scratch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(scratch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapeObj>())).resultindex as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(shapeObj),
            "::",
            stringify!(resultindex)
        )
    );
}
pub type multipointObj = lineObj;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geotransformObj {
    pub need_geotransform: ::std::os::raw::c_int,
    pub rotation_angle: f64,
    pub geotransform: [f64; 6usize],
    pub invgeotransform: [f64; 6usize],
}
#[test]
fn bindgen_test_layout_geotransformObj() {
    assert_eq!(
        ::std::mem::size_of::<geotransformObj>(),
        112usize,
        concat!("Size of: ", stringify!(geotransformObj))
    );
    assert_eq!(
        ::std::mem::align_of::<geotransformObj>(),
        8usize,
        concat!("Alignment of ", stringify!(geotransformObj))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geotransformObj>())).need_geotransform as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geotransformObj),
            "::",
            stringify!(need_geotransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geotransformObj>())).rotation_angle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geotransformObj),
            "::",
            stringify!(rotation_angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geotransformObj>())).geotransform as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geotransformObj),
            "::",
            stringify!(geotransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geotransformObj>())).invgeotransform as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(geotransformObj),
            "::",
            stringify!(invgeotransform)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashObj {
    pub next: *mut hashObj,
    pub key: *mut ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hashObj() {
    assert_eq!(
        ::std::mem::size_of::<hashObj>(),
        24usize,
        concat!("Size of: ", stringify!(hashObj))
    );
    assert_eq!(
        ::std::mem::align_of::<hashObj>(),
        8usize,
        concat!("Alignment of ", stringify!(hashObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashObj>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashObj),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashObj>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hashObj),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashObj>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hashObj),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " An object to store key-value pairs"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashTableObj {
    pub items: *mut *mut hashObj,
    #[doc = "< \\**immutable** number of items"]
    pub numitems: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_hashTableObj() {
    assert_eq!(
        ::std::mem::size_of::<hashTableObj>(),
        16usize,
        concat!("Size of: ", stringify!(hashTableObj))
    );
    assert_eq!(
        ::std::mem::align_of::<hashTableObj>(),
        8usize,
        concat!("Alignment of ", stringify!(hashTableObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashTableObj>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashTableObj),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashTableObj>())).numitems as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hashTableObj),
            "::",
            stringify!(numitems)
        )
    );
}
extern "C" {
    pub fn msCreateHashTable() -> *mut hashTableObj;
}
extern "C" {
    pub fn msFreeHashTable(table: *mut hashTableObj);
}
extern "C" {
    pub fn msFreeHashItems(table: *mut hashTableObj);
}
extern "C" {
    pub fn msInsertHashTable(
        table: *mut hashTableObj,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *mut hashObj;
}
extern "C" {
    pub fn msLookupHashTable(
        table: *const hashTableObj,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msRemoveHashTable(
        table: *mut hashTableObj,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFirstKeyFromHashTable(table: *const hashTableObj) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msNextKeyFromHashTable(
        table: *const hashTableObj,
        prevkey: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msHashIsEmpty(table: *const hashTableObj) -> ::std::os::raw::c_int;
}
pub type projPJ = *mut ::std::os::raw::c_void;
pub type projCtx = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct projectionContext {
    _unused: [u8; 0],
}
pub const msLineCuttingCase_LINE_CUTTING_UNKNOWN: msLineCuttingCase = -1;
pub const msLineCuttingCase_LINE_CUTTING_NONE: msLineCuttingCase = 0;
pub const msLineCuttingCase_LINE_CUTTING_FROM_POLAR: msLineCuttingCase = 1;
pub const msLineCuttingCase_LINE_CUTTING_FROM_LONGLAT_WRAP0: msLineCuttingCase = 2;
pub type msLineCuttingCase = ::std::os::raw::c_int;
#[doc = "The :ref:`PROJECTION <projection>` object"]
#[doc = "MapServer's Maps and Layers have Projection attributes, and these are C projectionObj structures,"]
#[doc = "but are not directly exposed by the mapscript module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct projectionObj {
    pub args: *mut *mut ::std::os::raw::c_char,
    pub proj: projPJ,
    pub proj_ctx: projCtx,
    pub gt: geotransformObj,
    #[doc = "< Actual number of projection args"]
    pub numargs: ::std::os::raw::c_int,
    #[doc = "< Projection object was to fetched from the layer"]
    pub automatic: ::std::os::raw::c_int,
    #[doc = "< One of ``wkp_none 0``, ``wkp_lonlat 1``, or ``wkp_gmerc 2``"]
    pub wellknownprojection: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_projectionObj() {
    assert_eq!(
        ::std::mem::size_of::<projectionObj>(),
        152usize,
        concat!("Size of: ", stringify!(projectionObj))
    );
    assert_eq!(
        ::std::mem::align_of::<projectionObj>(),
        8usize,
        concat!("Alignment of ", stringify!(projectionObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).args as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).proj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(proj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).proj_ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(proj_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).gt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(gt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).numargs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(numargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<projectionObj>())).automatic as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(automatic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<projectionObj>())).wellknownprojection as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(projectionObj),
            "::",
            stringify!(wellknownprojection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reprojectionObj {
    pub in_: *mut projectionObj,
    pub out: *mut projectionObj,
    pub lineCuttingCase: msLineCuttingCase,
    pub splitShape: shapeObj,
    pub no_op: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_reprojectionObj() {
    assert_eq!(
        ::std::mem::size_of::<reprojectionObj>(),
        144usize,
        concat!("Size of: ", stringify!(reprojectionObj))
    );
    assert_eq!(
        ::std::mem::align_of::<reprojectionObj>(),
        8usize,
        concat!("Alignment of ", stringify!(reprojectionObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reprojectionObj>())).in_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reprojectionObj),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reprojectionObj>())).out as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(reprojectionObj),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reprojectionObj>())).lineCuttingCase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(reprojectionObj),
            "::",
            stringify!(lineCuttingCase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reprojectionObj>())).splitShape as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(reprojectionObj),
            "::",
            stringify!(splitShape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reprojectionObj>())).no_op as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(reprojectionObj),
            "::",
            stringify!(no_op)
        )
    );
}
extern "C" {
    pub fn msProjectCreateReprojector(
        in_: *mut projectionObj,
        out: *mut projectionObj,
    ) -> *mut reprojectionObj;
}
extern "C" {
    pub fn msProjectDestroyReprojector(reprojector: *mut reprojectionObj);
}
extern "C" {
    pub fn msProjectionContextGetFromPool() -> *mut projectionContext;
}
extern "C" {
    pub fn msProjectionContextReleaseToPool(ctx: *mut projectionContext);
}
extern "C" {
    pub fn msProjectionContextPoolCleanup();
}
extern "C" {
    pub fn msIsAxisInverted(epsg_code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectPoint(
        in_: *mut projectionObj,
        out: *mut projectionObj,
        point: *mut pointObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectPointEx(
        reprojector: *mut reprojectionObj,
        point: *mut pointObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectShape(
        in_: *mut projectionObj,
        out: *mut projectionObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectShapeEx(
        reprojector: *mut reprojectionObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectLine(
        in_: *mut projectionObj,
        out: *mut projectionObj,
        line: *mut lineObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectLineEx(
        reprojector: *mut reprojectionObj,
        line: *mut lineObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectRect(
        in_: *mut projectionObj,
        out: *mut projectionObj,
        rect: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectRectAsPolygon(
        reprojector: *mut reprojectionObj,
        rect: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectionsDiffer(
        arg1: *mut projectionObj,
        arg2: *mut projectionObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGCWKT2ProjectionObj(
        pszWKT: *const ::std::os::raw::c_char,
        proj: *mut projectionObj,
        debug_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectionObj2OGCWKT(proj: *mut projectionObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msFreeProjection(p: *mut projectionObj);
}
extern "C" {
    pub fn msFreeProjectionExceptContext(p: *mut projectionObj);
}
extern "C" {
    pub fn msInitProjection(p: *mut projectionObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectionInheritContextFrom(pDst: *mut projectionObj, pSrc: *const projectionObj);
}
extern "C" {
    pub fn msProjectionSetContext(p: *mut projectionObj, ctx: *mut projectionContext);
}
extern "C" {
    pub fn msProcessProjection(p: *mut projectionObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadProjectionString(
        p: *mut projectionObj,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadProjectionStringEPSG(
        p: *mut projectionObj,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetProjectionString(proj: *mut projectionObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msIsAxisInvertedProj(proj: *mut projectionObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAxisSwapShape(shape: *mut shapeObj);
}
extern "C" {
    pub fn msAxisNormalizePoints(
        proj: *mut projectionObj,
        count: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
    );
}
extern "C" {
    pub fn msAxisDenormalizePoints(
        proj: *mut projectionObj,
        count: ::std::os::raw::c_int,
        x: *mut f64,
        y: *mut f64,
    );
}
extern "C" {
    pub fn msSetPROJ_DATA(arg1: *const ::std::os::raw::c_char, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn msProjDataInitFromEnv();
}
extern "C" {
    pub fn msProjIsGeographicCRS(proj: *mut projectionObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msProjectHasLonWrap(
        in_: *mut projectionObj,
        pdfLonWrap: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Opaque type for a FILE that implements the VSIVirtualHandle API"]
pub type VSILFILE = FILE;
pub type uchar = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHPInfo {
    pub fpSHP: *mut VSILFILE,
    pub fpSHX: *mut VSILFILE,
    pub nShapeType: ::std::os::raw::c_int,
    pub nFileSize: ::std::os::raw::c_int,
    pub nRecords: ::std::os::raw::c_int,
    pub nMaxRecords: ::std::os::raw::c_int,
    pub panRecOffset: *mut ::std::os::raw::c_int,
    pub panRecSize: *mut ::std::os::raw::c_int,
    pub panRecLoaded: ms_bitarray,
    pub panRecAllLoaded: ::std::os::raw::c_int,
    pub adBoundsMin: [f64; 4usize],
    pub adBoundsMax: [f64; 4usize],
    pub bUpdated: ::std::os::raw::c_int,
    pub nBufSize: ::std::os::raw::c_int,
    pub pabyRec: *mut uchar,
    pub nPartMax: ::std::os::raw::c_int,
    pub panParts: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SHPInfo() {
    assert_eq!(
        ::std::mem::size_of::<SHPInfo>(),
        160usize,
        concat!("Size of: ", stringify!(SHPInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SHPInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SHPInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).fpSHP as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(fpSHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).fpSHX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(fpSHX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nShapeType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nShapeType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nFileSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nFileSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nRecords as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nRecords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nMaxRecords as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nMaxRecords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).panRecOffset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(panRecOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).panRecSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(panRecSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).panRecLoaded as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(panRecLoaded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).panRecAllLoaded as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(panRecAllLoaded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).adBoundsMin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(adBoundsMin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).adBoundsMax as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(adBoundsMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).bUpdated as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(bUpdated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nBufSize as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nBufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).pabyRec as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(pabyRec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).nPartMax as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(nPartMax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPInfo>())).panParts as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPInfo),
            "::",
            stringify!(panParts)
        )
    );
}
pub type SHPHandle = *mut SHPInfo;
#[doc = " An object containing information about a DBF file"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DBFInfo {
    #[doc = "< Number of records in the DBF"]
    pub nRecords: ::std::os::raw::c_int,
    #[doc = "< Number of fields in the DBF"]
    pub nFields: ::std::os::raw::c_int,
    pub fp: *mut VSILFILE,
    pub nRecordLength: ::std::os::raw::c_uint,
    pub nHeaderLength: ::std::os::raw::c_int,
    pub panFieldOffset: *mut ::std::os::raw::c_int,
    pub panFieldSize: *mut ::std::os::raw::c_int,
    pub panFieldDecimals: *mut ::std::os::raw::c_int,
    pub pachFieldType: *mut ::std::os::raw::c_char,
    pub pszHeader: *mut ::std::os::raw::c_char,
    pub nCurrentRecord: ::std::os::raw::c_int,
    pub bCurrentRecordModified: ::std::os::raw::c_int,
    pub pszCurrentRecord: *mut ::std::os::raw::c_char,
    pub bNoHeader: ::std::os::raw::c_int,
    pub bUpdated: ::std::os::raw::c_int,
    pub pszStringField: *mut ::std::os::raw::c_char,
    pub nStringFieldLen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DBFInfo() {
    assert_eq!(
        ::std::mem::size_of::<DBFInfo>(),
        104usize,
        concat!("Size of: ", stringify!(DBFInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DBFInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(DBFInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nRecords as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nRecords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nFields as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nFields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).fp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nRecordLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nRecordLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nHeaderLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nHeaderLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).panFieldOffset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(panFieldOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).panFieldSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(panFieldSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).panFieldDecimals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(panFieldDecimals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).pachFieldType as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(pachFieldType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).pszHeader as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(pszHeader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nCurrentRecord as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nCurrentRecord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).bCurrentRecordModified as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(bCurrentRecordModified)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).pszCurrentRecord as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(pszCurrentRecord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).bNoHeader as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(bNoHeader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).bUpdated as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(bUpdated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).pszStringField as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(pszStringField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DBFInfo>())).nStringFieldLen as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(DBFInfo),
            "::",
            stringify!(nStringFieldLen)
        )
    );
}
pub type DBFHandle = *mut DBFInfo;
pub const DBFFieldType_FTString: DBFFieldType = 0;
pub const DBFFieldType_FTInteger: DBFFieldType = 1;
pub const DBFFieldType_FTDouble: DBFFieldType = 2;
pub const DBFFieldType_FTInvalid: DBFFieldType = 3;
pub type DBFFieldType = ::std::os::raw::c_uint;
#[doc = " An object representing a Shapefile. There is no write access to this object"]
#[doc = " using MapScript."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shapefileObj {
    #[doc = "< Shapefile type - see mapshape.h for values of type"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Number of shapes"]
    pub numshapes: ::std::os::raw::c_int,
    #[doc = "< Extent of shapes"]
    pub bounds: rectObj,
    pub source: [::std::os::raw::c_char; 1024usize],
    pub lastshape: ::std::os::raw::c_int,
    pub status: ms_bitarray,
    pub isopen: ::std::os::raw::c_int,
    pub hSHP: SHPHandle,
    pub hDBF: DBFHandle,
}
#[test]
fn bindgen_test_layout_shapefileObj() {
    assert_eq!(
        ::std::mem::size_of::<shapefileObj>(),
        1104usize,
        concat!("Size of: ", stringify!(shapefileObj))
    );
    assert_eq!(
        ::std::mem::align_of::<shapefileObj>(),
        8usize,
        concat!("Alignment of ", stringify!(shapefileObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).numshapes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(numshapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).bounds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).source as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).lastshape as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(lastshape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).status as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).isopen as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(isopen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).hSHP as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(hSHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shapefileObj>())).hDBF as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(shapefileObj),
            "::",
            stringify!(hDBF)
        )
    );
}
extern "C" {
    pub fn msShapefileOpenHandle(
        shpfile: *mut shapefileObj,
        filename: *const ::std::os::raw::c_char,
        hSHP: SHPHandle,
        hDBF: DBFHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapefileOpenVirtualFile(
        shpfile: *mut shapefileObj,
        filename: *const ::std::os::raw::c_char,
        fpSHP: *mut VSILFILE,
        fpSHX: *mut VSILFILE,
        fpDBF: *mut VSILFILE,
        log_failures: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapefileOpen(
        shpfile: *mut shapefileObj,
        mode: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        log_failures: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapefileCreate(
        shpfile: *mut shapefileObj,
        filename: *mut ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapefileClose(shpfile: *mut shapefileObj);
}
extern "C" {
    pub fn msShapefileWhichShapes(
        shpfile: *mut shapefileObj,
        rect: rectObj,
        debug: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSHPOpenVirtualFile(fpSHP: *mut VSILFILE, fpSHX: *mut VSILFILE) -> SHPHandle;
}
extern "C" {
    pub fn msSHPOpen(
        pszShapeFile: *const ::std::os::raw::c_char,
        pszAccess: *const ::std::os::raw::c_char,
    ) -> SHPHandle;
}
extern "C" {
    pub fn msSHPCreate(
        pszShapeFile: *const ::std::os::raw::c_char,
        nShapeType: ::std::os::raw::c_int,
    ) -> SHPHandle;
}
extern "C" {
    pub fn msSHPClose(hSHP: SHPHandle);
}
extern "C" {
    pub fn msSHPGetInfo(
        hSHP: SHPHandle,
        pnEntities: *mut ::std::os::raw::c_int,
        pnShapeType: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msSHPReadBounds(
        psSHP: SHPHandle,
        hEntity: ::std::os::raw::c_int,
        padBounds: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSHPReadShape(psSHP: SHPHandle, hEntity: ::std::os::raw::c_int, shape: *mut shapeObj);
}
extern "C" {
    pub fn msSHPReadPoint(
        psSHP: SHPHandle,
        hEntity: ::std::os::raw::c_int,
        point: *mut pointObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSHPWriteShape(psSHP: SHPHandle, shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSHPWritePoint(psSHP: SHPHandle, point: *mut pointObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFOpenVirtualFile(fp: *mut VSILFILE) -> DBFHandle;
}
extern "C" {
    pub fn msDBFOpen(
        pszDBFFile: *const ::std::os::raw::c_char,
        pszAccess: *const ::std::os::raw::c_char,
    ) -> DBFHandle;
}
extern "C" {
    pub fn msDBFClose(hDBF: DBFHandle);
}
extern "C" {
    pub fn msDBFCreate(pszDBFFile: *const ::std::os::raw::c_char) -> DBFHandle;
}
extern "C" {
    pub fn msDBFGetFieldCount(psDBF: DBFHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFGetRecordCount(psDBF: DBFHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFAddField(
        hDBF: DBFHandle,
        pszFieldName: *const ::std::os::raw::c_char,
        eType: DBFFieldType,
        nWidth: ::std::os::raw::c_int,
        nDecimals: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFGetFieldInfo(
        psDBF: DBFHandle,
        iField: ::std::os::raw::c_int,
        pszFieldName: *mut ::std::os::raw::c_char,
        pnWidth: *mut ::std::os::raw::c_int,
        pnDecimals: *mut ::std::os::raw::c_int,
    ) -> DBFFieldType;
}
extern "C" {
    pub fn msDBFReadIntegerAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFReadDoubleAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn msDBFReadStringAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDBFWriteIntegerAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
        nFieldValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFWriteDoubleAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
        dFieldValue: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFWriteStringAttribute(
        hDBF: DBFHandle,
        iShape: ::std::os::raw::c_int,
        iField: ::std::os::raw::c_int,
        pszFieldValue: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFGetItems(dbffile: DBFHandle) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDBFGetValues(
        dbffile: DBFHandle,
        record: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDBFGetValueList(
        dbffile: DBFHandle,
        record: ::std::os::raw::c_int,
        itemindexes: *mut ::std::os::raw::c_int,
        numitems: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDBFGetItemIndexes(
        dbffile: DBFHandle,
        items: *mut *mut ::std::os::raw::c_char,
        numitems: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDBFGetItemIndex(
        dbffile: DBFHandle,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct colorObj {
    pub red: ::std::os::raw::c_int,
    pub green: ::std::os::raw::c_int,
    pub blue: ::std::os::raw::c_int,
    pub alpha: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_colorObj() {
    assert_eq!(
        ::std::mem::size_of::<colorObj>(),
        16usize,
        concat!("Size of: ", stringify!(colorObj))
    );
    assert_eq!(
        ::std::mem::align_of::<colorObj>(),
        4usize,
        concat!("Alignment of ", stringify!(colorObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<colorObj>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(colorObj),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<colorObj>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(colorObj),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<colorObj>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(colorObj),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<colorObj>())).alpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(colorObj),
            "::",
            stringify!(alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rgbaArrayObj {
    pub pixels: *mut ::std::os::raw::c_uchar,
    pub pixel_step: ::std::os::raw::c_uint,
    pub row_step: ::std::os::raw::c_uint,
    pub a: *mut ::std::os::raw::c_uchar,
    pub r: *mut ::std::os::raw::c_uchar,
    pub g: *mut ::std::os::raw::c_uchar,
    pub b: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_rgbaArrayObj() {
    assert_eq!(
        ::std::mem::size_of::<rgbaArrayObj>(),
        48usize,
        concat!("Size of: ", stringify!(rgbaArrayObj))
    );
    assert_eq!(
        ::std::mem::align_of::<rgbaArrayObj>(),
        8usize,
        concat!("Alignment of ", stringify!(rgbaArrayObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).pixels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).pixel_step as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(pixel_step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).row_step as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(row_step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).r as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).g as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaArrayObj>())).b as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaArrayObj),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rgbaPixel {
    pub b: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub r: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_rgbaPixel() {
    assert_eq!(
        ::std::mem::size_of::<rgbaPixel>(),
        4usize,
        concat!("Size of: ", stringify!(rgbaPixel))
    );
    assert_eq!(
        ::std::mem::align_of::<rgbaPixel>(),
        1usize,
        concat!("Alignment of ", stringify!(rgbaPixel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaPixel>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaPixel),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaPixel>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaPixel),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaPixel>())).r as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaPixel),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rgbaPixel>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rgbaPixel),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paletteArrayObj {
    pub pixels: *mut ::std::os::raw::c_uchar,
    pub palette: *mut rgbaPixel,
    pub num_entries: ::std::os::raw::c_uint,
    pub scaling_maxval: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_paletteArrayObj() {
    assert_eq!(
        ::std::mem::size_of::<paletteArrayObj>(),
        24usize,
        concat!("Size of: ", stringify!(paletteArrayObj))
    );
    assert_eq!(
        ::std::mem::align_of::<paletteArrayObj>(),
        8usize,
        concat!("Alignment of ", stringify!(paletteArrayObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteArrayObj>())).pixels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteArrayObj),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteArrayObj>())).palette as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteArrayObj),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteArrayObj>())).num_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteArrayObj),
            "::",
            stringify!(num_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteArrayObj>())).scaling_maxval as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteArrayObj),
            "::",
            stringify!(scaling_maxval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rasterBufferObj {
    pub type_: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub data: rasterBufferObj__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rasterBufferObj__bindgen_ty_1 {
    pub rgba: rgbaArrayObj,
    pub palette: paletteArrayObj,
}
#[test]
fn bindgen_test_layout_rasterBufferObj__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rasterBufferObj__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(rasterBufferObj__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rasterBufferObj__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rasterBufferObj__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasterBufferObj__bindgen_ty_1>())).rgba as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj__bindgen_ty_1),
            "::",
            stringify!(rgba)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rasterBufferObj__bindgen_ty_1>())).palette as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj__bindgen_ty_1),
            "::",
            stringify!(palette)
        )
    );
}
#[test]
fn bindgen_test_layout_rasterBufferObj() {
    assert_eq!(
        ::std::mem::size_of::<rasterBufferObj>(),
        64usize,
        concat!("Size of: ", stringify!(rasterBufferObj))
    );
    assert_eq!(
        ::std::mem::align_of::<rasterBufferObj>(),
        8usize,
        concat!("Alignment of ", stringify!(rasterBufferObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasterBufferObj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasterBufferObj>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasterBufferObj>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rasterBufferObj>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rasterBufferObj),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imageCacheObj {
    pub symbol: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
    pub color: colorObj,
    pub outlinecolor: colorObj,
    pub backgroundcolor: colorObj,
    pub img: rasterBufferObj,
    pub next: *mut imageCacheObj,
}
#[test]
fn bindgen_test_layout_imageCacheObj() {
    assert_eq!(
        ::std::mem::size_of::<imageCacheObj>(),
        128usize,
        concat!("Size of: ", stringify!(imageCacheObj))
    );
    assert_eq!(
        ::std::mem::align_of::<imageCacheObj>(),
        8usize,
        concat!("Alignment of ", stringify!(imageCacheObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).color as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).outlinecolor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).backgroundcolor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(backgroundcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).img as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(img)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageCacheObj>())).next as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(imageCacheObj),
            "::",
            stringify!(next)
        )
    );
}
#[doc = "The :ref:`SYMBOL <symbol>` object"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct symbolObj {
    pub renderer: *mut rendererVTableObj,
    pub renderer_free_func: ::std::option::Option<unsafe extern "C" fn(self_: *mut symbolObj)>,
    pub pixmap_buffer: *mut rasterBufferObj,
    pub renderer_cache: *mut ::std::os::raw::c_void,
    pub full_pixmap_path: *mut ::std::os::raw::c_char,
    pub map: *mut mapObj,
    pub points: [pointObj; 100usize],
    #[doc = "< Reference counter"]
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< Number of points of a vector symbol"]
    pub numpoints: ::std::os::raw::c_int,
    #[doc = "< Path to pixmap file - see :ref:`IMAGE <mapfile-symbol-image>`"]
    pub imagepath: *mut ::std::os::raw::c_char,
    #[doc = "< Symbol name - see :ref:`NAME <mapfile-symbol-name>`"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`TYPE <mapfile-symbol-type>`"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Boolean value for writing - if set to :data:`TRUE`, the symbol will be saved inside the Mapfile. Added in MapServer 5.6.1"]
    pub inmapfile: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub sizex: f64,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub sizey: f64,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub minx: f64,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub miny: f64,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub maxx: f64,
    #[doc = "< :data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option"]
    pub maxy: f64,
    #[doc = "< :data:`MS_TRUE` or :data:`MS_FALSE` - see :ref:`FILLED <mapfile-symbol-filled>`"]
    pub filled: ::std::os::raw::c_int,
    #[doc = "< See :ref:`ANCHORPOINT <mapfile-symbol-anchorpoint>`"]
    pub anchorpoint_x: f64,
    #[doc = "< See :ref:`ANCHORPOINT <mapfile-symbol-anchorpoint>`"]
    pub anchorpoint_y: f64,
    #[doc = "< \\**TODO** Remove"]
    pub transparent: ::std::os::raw::c_int,
    #[doc = "< \\**TODO** Remove"]
    pub transparentcolor: ::std::os::raw::c_int,
    #[doc = "< For TrueType symbols - see :ref:`CHARACTER <mapfile-symbol-character>`"]
    pub character: *mut ::std::os::raw::c_char,
    #[doc = "< For TrueType symbols - see :ref:`FONT <mapfile-symbol-font>`"]
    pub font: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_symbolObj() {
    assert_eq!(
        ::std::mem::size_of::<symbolObj>(),
        3376usize,
        concat!("Size of: ", stringify!(symbolObj))
    );
    assert_eq!(
        ::std::mem::align_of::<symbolObj>(),
        8usize,
        concat!("Alignment of ", stringify!(symbolObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).renderer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).renderer_free_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(renderer_free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).pixmap_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(pixmap_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).renderer_cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(renderer_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).full_pixmap_path as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(full_pixmap_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).map as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).points as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).refcount as *const _ as usize },
        3248usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).numpoints as *const _ as usize },
        3252usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(numpoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).imagepath as *const _ as usize },
        3256usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(imagepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).name as *const _ as usize },
        3264usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).type_ as *const _ as usize },
        3272usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).inmapfile as *const _ as usize },
        3276usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(inmapfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).sizex as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(sizex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).sizey as *const _ as usize },
        3288usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(sizey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).minx as *const _ as usize },
        3296usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(minx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).miny as *const _ as usize },
        3304usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(miny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).maxx as *const _ as usize },
        3312usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(maxx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).maxy as *const _ as usize },
        3320usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(maxy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).filled as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(filled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).anchorpoint_x as *const _ as usize },
        3336usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(anchorpoint_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).anchorpoint_y as *const _ as usize },
        3344usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(anchorpoint_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).transparent as *const _ as usize },
        3352usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(transparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).transparentcolor as *const _ as usize },
        3356usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(transparentcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).character as *const _ as usize },
        3360usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(character)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolObj>())).font as *const _ as usize },
        3368usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolObj),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shape_tree_node {
    pub rect: rectObj,
    pub numshapes: ms_int32,
    pub ids: *mut ms_int32,
    pub numsubnodes: ::std::os::raw::c_int,
    pub subnode: [*mut shape_tree_node; 4usize],
}
#[test]
fn bindgen_test_layout_shape_tree_node() {
    assert_eq!(
        ::std::mem::size_of::<shape_tree_node>(),
        88usize,
        concat!("Size of: ", stringify!(shape_tree_node))
    );
    assert_eq!(
        ::std::mem::align_of::<shape_tree_node>(),
        8usize,
        concat!("Alignment of ", stringify!(shape_tree_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shape_tree_node>())).rect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shape_tree_node),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shape_tree_node>())).numshapes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shape_tree_node),
            "::",
            stringify!(numshapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shape_tree_node>())).ids as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shape_tree_node),
            "::",
            stringify!(ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shape_tree_node>())).numsubnodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shape_tree_node),
            "::",
            stringify!(numsubnodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shape_tree_node>())).subnode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shape_tree_node),
            "::",
            stringify!(subnode)
        )
    );
}
pub type treeNodeObj = shape_tree_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct treeObj {
    pub numshapes: ms_int32,
    pub maxdepth: ms_int32,
    pub root: *mut treeNodeObj,
}
#[test]
fn bindgen_test_layout_treeObj() {
    assert_eq!(
        ::std::mem::size_of::<treeObj>(),
        16usize,
        concat!("Size of: ", stringify!(treeObj))
    );
    assert_eq!(
        ::std::mem::align_of::<treeObj>(),
        8usize,
        concat!("Alignment of ", stringify!(treeObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<treeObj>())).numshapes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(treeObj),
            "::",
            stringify!(numshapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<treeObj>())).maxdepth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(treeObj),
            "::",
            stringify!(maxdepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<treeObj>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(treeObj),
            "::",
            stringify!(root)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHPTreeInfo {
    pub fp: *mut FILE,
    pub signature: [::std::os::raw::c_char; 3usize],
    pub LSB_order: ::std::os::raw::c_char,
    pub needswap: ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_char,
    pub flags: [::std::os::raw::c_char; 3usize],
    pub nShapes: ms_int32,
    pub nDepth: ms_int32,
}
#[test]
fn bindgen_test_layout_SHPTreeInfo() {
    assert_eq!(
        ::std::mem::size_of::<SHPTreeInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SHPTreeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SHPTreeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SHPTreeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).LSB_order as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(LSB_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).needswap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(needswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).version as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).flags as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).nShapes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(nShapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SHPTreeInfo>())).nDepth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SHPTreeInfo),
            "::",
            stringify!(nDepth)
        )
    );
}
pub type SHPTreeHandle = *mut SHPTreeInfo;
extern "C" {
    pub fn msSHPDiskTreeOpen(
        pszTree: *const ::std::os::raw::c_char,
        debug: ::std::os::raw::c_int,
    ) -> SHPTreeHandle;
}
extern "C" {
    pub fn msSHPDiskTreeClose(disktree: SHPTreeHandle);
}
extern "C" {
    pub fn msCreateTree(
        shapefile: *mut shapefileObj,
        maxdepth: ::std::os::raw::c_int,
    ) -> *mut treeObj;
}
extern "C" {
    pub fn msTreeTrim(tree: *mut treeObj);
}
extern "C" {
    pub fn msDestroyTree(tree: *mut treeObj);
}
extern "C" {
    pub fn msSearchTree(tree: *const treeObj, aoi: rectObj) -> ms_bitarray;
}
extern "C" {
    pub fn msSearchDiskTree(
        filename: *const ::std::os::raw::c_char,
        aoi: rectObj,
        debug: ::std::os::raw::c_int,
        numshapes: ::std::os::raw::c_int,
    ) -> ms_bitarray;
}
extern "C" {
    pub fn msReadTree(
        filename: *mut ::std::os::raw::c_char,
        debug: ::std::os::raw::c_int,
    ) -> *mut treeObj;
}
extern "C" {
    pub fn msWriteTree(
        tree: *mut treeObj,
        filename: *mut ::std::os::raw::c_char,
        LSB_order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFilterTreeSearch(shp: *mut shapefileObj, status: ms_bitarray, search_rect: rectObj);
}
extern "C" {
    pub fn msIO_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_fprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_fwrite(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_fread(
        ptr: *mut ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_vfprintf(
        fp: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type msIO_llReadWriteFunc = ::std::option::Option<
    unsafe extern "C" fn(
        cbData: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        byteCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msIOContext_t {
    pub label: *const ::std::os::raw::c_char,
    pub write_channel: ::std::os::raw::c_int,
    pub readWriteFunc: msIO_llReadWriteFunc,
    pub cbData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_msIOContext_t() {
    assert_eq!(
        ::std::mem::size_of::<msIOContext_t>(),
        32usize,
        concat!("Size of: ", stringify!(msIOContext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<msIOContext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(msIOContext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msIOContext_t>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msIOContext_t),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msIOContext_t>())).write_channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msIOContext_t),
            "::",
            stringify!(write_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msIOContext_t>())).readWriteFunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msIOContext_t),
            "::",
            stringify!(readWriteFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msIOContext_t>())).cbData as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msIOContext_t),
            "::",
            stringify!(cbData)
        )
    );
}
pub type msIOContext = msIOContext_t;
extern "C" {
    pub fn msIO_installHandlers(
        stdin_context: *mut msIOContext,
        stdout_context: *mut msIOContext,
        stderr_context: *mut msIOContext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_getHandler(arg1: *mut FILE) -> *mut msIOContext;
}
extern "C" {
    pub fn msIO_setHeaderEnabled(bFlag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msIO_setHeader(
        header: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn msIO_sendHeaders();
}
extern "C" {
    pub fn msIO_contextRead(
        context: *mut msIOContext,
        data: *mut ::std::os::raw::c_void,
        byteCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_contextWrite(
        context: *mut msIOContext,
        data: *const ::std::os::raw::c_void,
        byteCount: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_bufferRead(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_bufferWrite(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_resetHandlers();
}
extern "C" {
    pub fn msIO_installStdoutToBuffer();
}
extern "C" {
    pub fn msIO_installStdinFromBuffer();
}
extern "C" {
    pub fn msIO_Cleanup();
}
extern "C" {
    pub fn msIO_stripStdoutBufferContentType() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msIO_stripStdoutBufferContentHeaders();
}
extern "C" {
    pub fn msIO_getAndStripStdoutBufferMimeHeaders() -> *mut hashTableObj;
}
extern "C" {
    pub fn msIO_pushStdoutToBufferAndGetOldContext() -> *mut msIOContext;
}
extern "C" {
    pub fn msIO_restoreOldStdoutContext(context_to_restore: *mut msIOContext);
}
extern "C" {
    pub fn msIO_isStdContext() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_needBinaryStdout() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIO_needBinaryStdin() -> ::std::os::raw::c_int;
}
pub const MS_REQUEST_TYPE_MS_GET_REQUEST: MS_REQUEST_TYPE = 0;
pub const MS_REQUEST_TYPE_MS_POST_REQUEST: MS_REQUEST_TYPE = 1;
pub type MS_REQUEST_TYPE = ::std::os::raw::c_uint;
#[doc = "Class for programming OWS services"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgiRequestObj {
    pub ParamNames: *mut *mut ::std::os::raw::c_char,
    pub ParamValues: *mut *mut ::std::os::raw::c_char,
    #[doc = "< The number of querystring parameters"]
    pub NumParams: ::std::os::raw::c_int,
    #[doc = "< A :ref:`request type constant<mapfile-constants-requesttype>`"]
    pub type_: MS_REQUEST_TYPE,
    #[doc = "< The content type of the request"]
    pub contenttype: *mut ::std::os::raw::c_char,
    #[doc = "< Any POST data request"]
    pub postrequest: *mut ::std::os::raw::c_char,
    #[doc = "< Any cookie data associated with the request"]
    pub httpcookiedata: *mut ::std::os::raw::c_char,
    pub path_info: *const ::std::os::raw::c_char,
    pub api_path_length: ::std::os::raw::c_int,
    pub api_path: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cgiRequestObj() {
    assert_eq!(
        ::std::mem::size_of::<cgiRequestObj>(),
        72usize,
        concat!("Size of: ", stringify!(cgiRequestObj))
    );
    assert_eq!(
        ::std::mem::align_of::<cgiRequestObj>(),
        8usize,
        concat!("Alignment of ", stringify!(cgiRequestObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).ParamNames as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(ParamNames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).ParamValues as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(ParamValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).NumParams as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(NumParams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).contenttype as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(contenttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).postrequest as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(postrequest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).httpcookiedata as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(httpcookiedata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).path_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(path_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).api_path_length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(api_path_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cgiRequestObj>())).api_path as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cgiRequestObj),
            "::",
            stringify!(api_path)
        )
    );
}
extern "C" {
    pub fn msAllocCgiObj() -> *mut cgiRequestObj;
}
extern "C" {
    pub fn msFreeCgiObj(request: *mut cgiRequestObj);
}
#[doc = "The :ref:`CONFIG <config>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct configObj {
    #[doc = "< Key-value pairs of environment variables and values"]
    pub env: hashTableObj,
    #[doc = "< Key-value pairs of Mapfile names and paths"]
    pub maps: hashTableObj,
    #[doc = "< Key-value pairs of plugin names and paths"]
    pub plugins: hashTableObj,
}
#[test]
fn bindgen_test_layout_configObj() {
    assert_eq!(
        ::std::mem::size_of::<configObj>(),
        48usize,
        concat!("Size of: ", stringify!(configObj))
    );
    assert_eq!(
        ::std::mem::align_of::<configObj>(),
        8usize,
        concat!("Alignment of ", stringify!(configObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<configObj>())).env as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(configObj),
            "::",
            stringify!(env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<configObj>())).maps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(configObj),
            "::",
            stringify!(maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<configObj>())).plugins as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(configObj),
            "::",
            stringify!(plugins)
        )
    );
}
extern "C" {
    pub fn msLoadConfig(ms_config_file: *const ::std::os::raw::c_char) -> *mut configObj;
}
extern "C" {
    pub fn msFreeConfig(config: *mut configObj);
}
extern "C" {
    pub fn msConfigGetEnv(
        config: *const configObj,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msConfigGetMap(
        config: *const configObj,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msConfigGetPlugin(
        config: *const configObj,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ms_regex_t {
    pub sys_regex: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ms_regex_t() {
    assert_eq!(
        ::std::mem::size_of::<ms_regex_t>(),
        8usize,
        concat!("Size of: ", stringify!(ms_regex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ms_regex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ms_regex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ms_regex_t>())).sys_regex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ms_regex_t),
            "::",
            stringify!(sys_regex)
        )
    );
}
pub type ms_regoff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ms_regmatch_t {
    pub rm_so: ms_regoff_t,
    pub rm_eo: ms_regoff_t,
}
#[test]
fn bindgen_test_layout_ms_regmatch_t() {
    assert_eq!(
        ::std::mem::size_of::<ms_regmatch_t>(),
        8usize,
        concat!("Size of: ", stringify!(ms_regmatch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ms_regmatch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ms_regmatch_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ms_regmatch_t>())).rm_so as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ms_regmatch_t),
            "::",
            stringify!(rm_so)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ms_regmatch_t>())).rm_eo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ms_regmatch_t),
            "::",
            stringify!(rm_eo)
        )
    );
}
extern "C" {
    pub fn ms_regcomp(
        arg1: *mut ms_regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ms_regerror(
        arg1: ::std::os::raw::c_int,
        arg2: *const ms_regex_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn ms_regexec(
        arg1: *const ms_regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut ms_regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ms_regfree(arg1: *mut ms_regex_t);
}
#[doc = "< unknown type, non-standard"]
pub const OGRwkbGeometryType_wkbUnknown: OGRwkbGeometryType = 0;
#[doc = "< 0-dimensional geometric object, standard WKB"]
pub const OGRwkbGeometryType_wkbPoint: OGRwkbGeometryType = 1;
#[doc = "< 1-dimensional geometric object with linear"]
#[doc = "   interpolation between Points, standard WKB"]
pub const OGRwkbGeometryType_wkbLineString: OGRwkbGeometryType = 2;
#[doc = "< planar 2-dimensional geometric object defined"]
#[doc = "   by 1 exterior boundary and 0 or more interior"]
#[doc = "   boundaries, standard WKB"]
pub const OGRwkbGeometryType_wkbPolygon: OGRwkbGeometryType = 3;
#[doc = "< GeometryCollection of Points, standard WKB"]
pub const OGRwkbGeometryType_wkbMultiPoint: OGRwkbGeometryType = 4;
#[doc = "< GeometryCollection of LineStrings, standard WKB"]
pub const OGRwkbGeometryType_wkbMultiLineString: OGRwkbGeometryType = 5;
#[doc = "< GeometryCollection of Polygons, standard WKB"]
pub const OGRwkbGeometryType_wkbMultiPolygon: OGRwkbGeometryType = 6;
#[doc = "< geometric object that is a collection of 1"]
#[doc = "or more geometric objects, standard WKB"]
pub const OGRwkbGeometryType_wkbGeometryCollection: OGRwkbGeometryType = 7;
#[doc = "< one or more circular arc segments connected end to end,"]
#[doc = "   ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCircularString: OGRwkbGeometryType = 8;
#[doc = "< sequence of contiguous curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCompoundCurve: OGRwkbGeometryType = 9;
#[doc = "< planar surface, defined by 1 exterior boundary"]
#[doc = "   and zero or more interior boundaries, that are curves."]
#[doc = "    ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCurvePolygon: OGRwkbGeometryType = 10;
#[doc = "< GeometryCollection of Curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbMultiCurve: OGRwkbGeometryType = 11;
#[doc = "< GeometryCollection of Surfaces, ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbMultiSurface: OGRwkbGeometryType = 12;
#[doc = "< Curve (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurve: OGRwkbGeometryType = 13;
#[doc = "< Surface (abstract type). ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbSurface: OGRwkbGeometryType = 14;
#[doc = "< a contiguous collection of polygons, which share common boundary segments,"]
#[doc = "   ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbPolyhedralSurface: OGRwkbGeometryType = 15;
#[doc = "< a PolyhedralSurface consisting only of Triangle patches"]
#[doc = "    ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTIN: OGRwkbGeometryType = 16;
#[doc = "< a Triangle. ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTriangle: OGRwkbGeometryType = 17;
#[doc = "< non-standard, for pure attribute records"]
pub const OGRwkbGeometryType_wkbNone: OGRwkbGeometryType = 100;
#[doc = "< non-standard, just for createGeometry()"]
pub const OGRwkbGeometryType_wkbLinearRing: OGRwkbGeometryType = 101;
#[doc = "< wkbCircularString with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCircularStringZ: OGRwkbGeometryType = 1008;
#[doc = "< wkbCompoundCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCompoundCurveZ: OGRwkbGeometryType = 1009;
#[doc = "< wkbCurvePolygon with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbCurvePolygonZ: OGRwkbGeometryType = 1010;
#[doc = "< wkbMultiCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbMultiCurveZ: OGRwkbGeometryType = 1011;
#[doc = "< wkbMultiSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0"]
pub const OGRwkbGeometryType_wkbMultiSurfaceZ: OGRwkbGeometryType = 1012;
#[doc = "< wkbCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurveZ: OGRwkbGeometryType = 1013;
#[doc = "< wkbSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbSurfaceZ: OGRwkbGeometryType = 1014;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbPolyhedralSurfaceZ: OGRwkbGeometryType = 1015;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTINZ: OGRwkbGeometryType = 1016;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTriangleZ: OGRwkbGeometryType = 1017;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbPointM: OGRwkbGeometryType = 2001;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbLineStringM: OGRwkbGeometryType = 2002;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbPolygonM: OGRwkbGeometryType = 2003;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiPointM: OGRwkbGeometryType = 2004;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiLineStringM: OGRwkbGeometryType = 2005;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiPolygonM: OGRwkbGeometryType = 2006;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbGeometryCollectionM: OGRwkbGeometryType = 2007;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCircularStringM: OGRwkbGeometryType = 2008;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCompoundCurveM: OGRwkbGeometryType = 2009;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurvePolygonM: OGRwkbGeometryType = 2010;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiCurveM: OGRwkbGeometryType = 2011;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiSurfaceM: OGRwkbGeometryType = 2012;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurveM: OGRwkbGeometryType = 2013;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbSurfaceM: OGRwkbGeometryType = 2014;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbPolyhedralSurfaceM: OGRwkbGeometryType = 2015;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTINM: OGRwkbGeometryType = 2016;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTriangleM: OGRwkbGeometryType = 2017;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbPointZM: OGRwkbGeometryType = 3001;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbLineStringZM: OGRwkbGeometryType = 3002;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbPolygonZM: OGRwkbGeometryType = 3003;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiPointZM: OGRwkbGeometryType = 3004;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiLineStringZM: OGRwkbGeometryType = 3005;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiPolygonZM: OGRwkbGeometryType = 3006;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbGeometryCollectionZM: OGRwkbGeometryType = 3007;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCircularStringZM: OGRwkbGeometryType = 3008;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCompoundCurveZM: OGRwkbGeometryType = 3009;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurvePolygonZM: OGRwkbGeometryType = 3010;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiCurveZM: OGRwkbGeometryType = 3011;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbMultiSurfaceZM: OGRwkbGeometryType = 3012;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbCurveZM: OGRwkbGeometryType = 3013;
#[doc = "< ISO SQL/MM Part 3. GDAL &gt;= 2.1"]
pub const OGRwkbGeometryType_wkbSurfaceZM: OGRwkbGeometryType = 3014;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbPolyhedralSurfaceZM: OGRwkbGeometryType = 3015;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTINZM: OGRwkbGeometryType = 3016;
#[doc = "< ISO SQL/MM Part 3. Reserved in GDAL &gt;= 2.1 but not yet implemented"]
pub const OGRwkbGeometryType_wkbTriangleZM: OGRwkbGeometryType = 3017;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbPoint25D: OGRwkbGeometryType = 2147483649;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbLineString25D: OGRwkbGeometryType = 2147483650;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbPolygon25D: OGRwkbGeometryType = 2147483651;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbMultiPoint25D: OGRwkbGeometryType = 2147483652;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbMultiLineString25D: OGRwkbGeometryType = 2147483653;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbMultiPolygon25D: OGRwkbGeometryType = 2147483654;
#[doc = "< 2.5D extension as per 99-402"]
pub const OGRwkbGeometryType_wkbGeometryCollection25D: OGRwkbGeometryType = 2147483655;
#[doc = " List of well known binary geometry types.  These are used within the BLOBs"]
#[doc = " but are also returned from OGRGeometry::getGeometryType() to identify the"]
#[doc = " type of a geometry object."]
pub type OGRwkbGeometryType = ::std::os::raw::c_uint;
#[doc = " Opaque type for a geometry"]
pub type OGRGeometryH = *mut ::std::os::raw::c_void;
pub const MS_UNITS_MS_INCHES: MS_UNITS = 0;
pub const MS_UNITS_MS_FEET: MS_UNITS = 1;
pub const MS_UNITS_MS_MILES: MS_UNITS = 2;
pub const MS_UNITS_MS_METERS: MS_UNITS = 3;
pub const MS_UNITS_MS_KILOMETERS: MS_UNITS = 4;
pub const MS_UNITS_MS_DD: MS_UNITS = 5;
pub const MS_UNITS_MS_PIXELS: MS_UNITS = 6;
pub const MS_UNITS_MS_PERCENTAGES: MS_UNITS = 7;
pub const MS_UNITS_MS_NAUTICALMILES: MS_UNITS = 8;
pub const MS_UNITS_MS_INHERIT: MS_UNITS = -1;
pub type MS_UNITS = ::std::os::raw::c_int;
pub const MS_LAYER_TYPE_MS_LAYER_POINT: MS_LAYER_TYPE = 0;
pub const MS_LAYER_TYPE_MS_LAYER_LINE: MS_LAYER_TYPE = 1;
pub const MS_LAYER_TYPE_MS_LAYER_POLYGON: MS_LAYER_TYPE = 2;
pub const MS_LAYER_TYPE_MS_LAYER_RASTER: MS_LAYER_TYPE = 3;
pub const MS_LAYER_TYPE_MS_LAYER_ANNOTATION: MS_LAYER_TYPE = 4;
pub const MS_LAYER_TYPE_MS_LAYER_QUERY: MS_LAYER_TYPE = 5;
pub const MS_LAYER_TYPE_MS_LAYER_CIRCLE: MS_LAYER_TYPE = 6;
pub const MS_LAYER_TYPE_MS_LAYER_TILEINDEX: MS_LAYER_TYPE = 7;
pub const MS_LAYER_TYPE_MS_LAYER_CHART: MS_LAYER_TYPE = 8;
pub type MS_LAYER_TYPE = ::std::os::raw::c_uint;
pub const MS_RENDER_MODE_MS_FIRST_MATCHING_CLASS: MS_RENDER_MODE = 0;
pub const MS_RENDER_MODE_MS_ALL_MATCHING_CLASSES: MS_RENDER_MODE = 1;
pub type MS_RENDER_MODE = ::std::os::raw::c_uint;
pub const MS_POSITIONS_ENUM_MS_UL: MS_POSITIONS_ENUM = 101;
pub const MS_POSITIONS_ENUM_MS_LR: MS_POSITIONS_ENUM = 102;
pub const MS_POSITIONS_ENUM_MS_UR: MS_POSITIONS_ENUM = 103;
pub const MS_POSITIONS_ENUM_MS_LL: MS_POSITIONS_ENUM = 104;
pub const MS_POSITIONS_ENUM_MS_CR: MS_POSITIONS_ENUM = 105;
pub const MS_POSITIONS_ENUM_MS_CL: MS_POSITIONS_ENUM = 106;
pub const MS_POSITIONS_ENUM_MS_UC: MS_POSITIONS_ENUM = 107;
pub const MS_POSITIONS_ENUM_MS_LC: MS_POSITIONS_ENUM = 108;
pub const MS_POSITIONS_ENUM_MS_CC: MS_POSITIONS_ENUM = 109;
pub const MS_POSITIONS_ENUM_MS_AUTO: MS_POSITIONS_ENUM = 110;
pub const MS_POSITIONS_ENUM_MS_XY: MS_POSITIONS_ENUM = 111;
pub const MS_POSITIONS_ENUM_MS_NONE: MS_POSITIONS_ENUM = 112;
pub const MS_POSITIONS_ENUM_MS_AUTO2: MS_POSITIONS_ENUM = 113;
pub const MS_POSITIONS_ENUM_MS_FOLLOW: MS_POSITIONS_ENUM = 114;
pub type MS_POSITIONS_ENUM = ::std::os::raw::c_uint;
pub const MS_CONNECTION_TYPE_MS_INLINE: MS_CONNECTION_TYPE = 0;
pub const MS_CONNECTION_TYPE_MS_SHAPEFILE: MS_CONNECTION_TYPE = 1;
pub const MS_CONNECTION_TYPE_MS_TILED_SHAPEFILE: MS_CONNECTION_TYPE = 2;
pub const MS_CONNECTION_TYPE_MS_UNUSED_2: MS_CONNECTION_TYPE = 3;
pub const MS_CONNECTION_TYPE_MS_OGR: MS_CONNECTION_TYPE = 4;
pub const MS_CONNECTION_TYPE_MS_UNUSED_1: MS_CONNECTION_TYPE = 5;
pub const MS_CONNECTION_TYPE_MS_POSTGIS: MS_CONNECTION_TYPE = 6;
pub const MS_CONNECTION_TYPE_MS_WMS: MS_CONNECTION_TYPE = 7;
pub const MS_CONNECTION_TYPE_MS_ORACLESPATIAL: MS_CONNECTION_TYPE = 8;
pub const MS_CONNECTION_TYPE_MS_WFS: MS_CONNECTION_TYPE = 9;
pub const MS_CONNECTION_TYPE_MS_GRATICULE: MS_CONNECTION_TYPE = 10;
pub const MS_CONNECTION_TYPE_MS_MYSQL: MS_CONNECTION_TYPE = 11;
pub const MS_CONNECTION_TYPE_MS_RASTER: MS_CONNECTION_TYPE = 12;
pub const MS_CONNECTION_TYPE_MS_PLUGIN: MS_CONNECTION_TYPE = 13;
pub const MS_CONNECTION_TYPE_MS_UNION: MS_CONNECTION_TYPE = 14;
pub const MS_CONNECTION_TYPE_MS_UVRASTER: MS_CONNECTION_TYPE = 15;
pub const MS_CONNECTION_TYPE_MS_CONTOUR: MS_CONNECTION_TYPE = 16;
pub const MS_CONNECTION_TYPE_MS_KERNELDENSITY: MS_CONNECTION_TYPE = 17;
pub const MS_CONNECTION_TYPE_MS_IDW: MS_CONNECTION_TYPE = 18;
pub const MS_CONNECTION_TYPE_MS_FLATGEOBUF: MS_CONNECTION_TYPE = 19;
pub type MS_CONNECTION_TYPE = ::std::os::raw::c_uint;
pub const MS_JOIN_CONNECTION_TYPE_MS_DB_XBASE: MS_JOIN_CONNECTION_TYPE = 0;
pub const MS_JOIN_CONNECTION_TYPE_MS_DB_CSV: MS_JOIN_CONNECTION_TYPE = 1;
pub const MS_JOIN_CONNECTION_TYPE_MS_DB_MYSQL: MS_JOIN_CONNECTION_TYPE = 2;
pub const MS_JOIN_CONNECTION_TYPE_MS_DB_ORACLE: MS_JOIN_CONNECTION_TYPE = 3;
pub const MS_JOIN_CONNECTION_TYPE_MS_DB_POSTGRES: MS_JOIN_CONNECTION_TYPE = 4;
pub type MS_JOIN_CONNECTION_TYPE = ::std::os::raw::c_uint;
pub const MS_JOIN_TYPE_MS_JOIN_ONE_TO_ONE: MS_JOIN_TYPE = 0;
pub const MS_JOIN_TYPE_MS_JOIN_ONE_TO_MANY: MS_JOIN_TYPE = 1;
pub type MS_JOIN_TYPE = ::std::os::raw::c_uint;
pub const MS_TRANSFORM_MODE_MS_TRANSFORM_NONE: MS_TRANSFORM_MODE = 0;
pub const MS_TRANSFORM_MODE_MS_TRANSFORM_ROUND: MS_TRANSFORM_MODE = 1;
pub const MS_TRANSFORM_MODE_MS_TRANSFORM_SNAPTOGRID: MS_TRANSFORM_MODE = 2;
pub const MS_TRANSFORM_MODE_MS_TRANSFORM_FULLRESOLUTION: MS_TRANSFORM_MODE = 3;
pub const MS_TRANSFORM_MODE_MS_TRANSFORM_SIMPLIFY: MS_TRANSFORM_MODE = 4;
pub type MS_TRANSFORM_MODE = ::std::os::raw::c_uint;
pub const CompositingOperation_MS_COMPOP_CLEAR: CompositingOperation = 0;
pub const CompositingOperation_MS_COMPOP_SRC: CompositingOperation = 1;
pub const CompositingOperation_MS_COMPOP_DST: CompositingOperation = 2;
pub const CompositingOperation_MS_COMPOP_SRC_OVER: CompositingOperation = 3;
pub const CompositingOperation_MS_COMPOP_DST_OVER: CompositingOperation = 4;
pub const CompositingOperation_MS_COMPOP_SRC_IN: CompositingOperation = 5;
pub const CompositingOperation_MS_COMPOP_DST_IN: CompositingOperation = 6;
pub const CompositingOperation_MS_COMPOP_SRC_OUT: CompositingOperation = 7;
pub const CompositingOperation_MS_COMPOP_DST_OUT: CompositingOperation = 8;
pub const CompositingOperation_MS_COMPOP_SRC_ATOP: CompositingOperation = 9;
pub const CompositingOperation_MS_COMPOP_DST_ATOP: CompositingOperation = 10;
pub const CompositingOperation_MS_COMPOP_XOR: CompositingOperation = 11;
pub const CompositingOperation_MS_COMPOP_PLUS: CompositingOperation = 12;
pub const CompositingOperation_MS_COMPOP_MINUS: CompositingOperation = 13;
pub const CompositingOperation_MS_COMPOP_MULTIPLY: CompositingOperation = 14;
pub const CompositingOperation_MS_COMPOP_SCREEN: CompositingOperation = 15;
pub const CompositingOperation_MS_COMPOP_OVERLAY: CompositingOperation = 16;
pub const CompositingOperation_MS_COMPOP_DARKEN: CompositingOperation = 17;
pub const CompositingOperation_MS_COMPOP_LIGHTEN: CompositingOperation = 18;
pub const CompositingOperation_MS_COMPOP_COLOR_DODGE: CompositingOperation = 19;
pub const CompositingOperation_MS_COMPOP_COLOR_BURN: CompositingOperation = 20;
pub const CompositingOperation_MS_COMPOP_HARD_LIGHT: CompositingOperation = 21;
pub const CompositingOperation_MS_COMPOP_SOFT_LIGHT: CompositingOperation = 22;
pub const CompositingOperation_MS_COMPOP_DIFFERENCE: CompositingOperation = 23;
pub const CompositingOperation_MS_COMPOP_EXCLUSION: CompositingOperation = 24;
pub const CompositingOperation_MS_COMPOP_CONTRAST: CompositingOperation = 25;
pub const CompositingOperation_MS_COMPOP_INVERT: CompositingOperation = 26;
pub const CompositingOperation_MS_COMPOP_INVERT_RGB: CompositingOperation = 27;
pub type CompositingOperation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CompositingFilter {
    pub filter: *mut ::std::os::raw::c_char,
    pub next: *mut _CompositingFilter,
}
#[test]
fn bindgen_test_layout__CompositingFilter() {
    assert_eq!(
        ::std::mem::size_of::<_CompositingFilter>(),
        16usize,
        concat!("Size of: ", stringify!(_CompositingFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<_CompositingFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(_CompositingFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CompositingFilter>())).filter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompositingFilter),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CompositingFilter>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompositingFilter),
            "::",
            stringify!(next)
        )
    );
}
pub type CompositingFilter = _CompositingFilter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LayerCompositer {
    pub comp_op: CompositingOperation,
    pub opacity: ::std::os::raw::c_int,
    pub filter: *mut CompositingFilter,
    pub next: *mut _LayerCompositer,
}
#[test]
fn bindgen_test_layout__LayerCompositer() {
    assert_eq!(
        ::std::mem::size_of::<_LayerCompositer>(),
        24usize,
        concat!("Size of: ", stringify!(_LayerCompositer))
    );
    assert_eq!(
        ::std::mem::align_of::<_LayerCompositer>(),
        8usize,
        concat!("Alignment of ", stringify!(_LayerCompositer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LayerCompositer>())).comp_op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LayerCompositer),
            "::",
            stringify!(comp_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LayerCompositer>())).opacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LayerCompositer),
            "::",
            stringify!(opacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LayerCompositer>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LayerCompositer),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LayerCompositer>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_LayerCompositer),
            "::",
            stringify!(next)
        )
    );
}
pub type LayerCompositer = _LayerCompositer;
pub const FilterNodeType_FILTER_NODE_TYPE_UNDEFINED: FilterNodeType = -1;
pub const FilterNodeType_FILTER_NODE_TYPE_LOGICAL: FilterNodeType = 0;
pub const FilterNodeType_FILTER_NODE_TYPE_SPATIAL: FilterNodeType = 1;
pub const FilterNodeType_FILTER_NODE_TYPE_COMPARISON: FilterNodeType = 2;
pub const FilterNodeType_FILTER_NODE_TYPE_PROPERTYNAME: FilterNodeType = 3;
pub const FilterNodeType_FILTER_NODE_TYPE_BBOX: FilterNodeType = 4;
pub const FilterNodeType_FILTER_NODE_TYPE_LITERAL: FilterNodeType = 5;
pub const FilterNodeType_FILTER_NODE_TYPE_BOUNDARY: FilterNodeType = 6;
pub const FilterNodeType_FILTER_NODE_TYPE_GEOMETRY_POINT: FilterNodeType = 7;
pub const FilterNodeType_FILTER_NODE_TYPE_GEOMETRY_LINE: FilterNodeType = 8;
pub const FilterNodeType_FILTER_NODE_TYPE_GEOMETRY_POLYGON: FilterNodeType = 9;
pub const FilterNodeType_FILTER_NODE_TYPE_FEATUREID: FilterNodeType = 10;
pub const FilterNodeType_FILTER_NODE_TYPE_TEMPORAL: FilterNodeType = 11;
pub const FilterNodeType_FILTER_NODE_TYPE_TIME_PERIOD: FilterNodeType = 12;
pub type FilterNodeType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FilterNode {
    pub eType: FilterNodeType,
    pub pszValue: *mut ::std::os::raw::c_char,
    pub pOther: *mut ::std::os::raw::c_void,
    pub pszSRS: *mut ::std::os::raw::c_char,
    pub psLeftNode: *mut _FilterNode,
    pub psRightNode: *mut _FilterNode,
}
#[test]
fn bindgen_test_layout__FilterNode() {
    assert_eq!(
        ::std::mem::size_of::<_FilterNode>(),
        48usize,
        concat!("Size of: ", stringify!(_FilterNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_FilterNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_FilterNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).eType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).pszValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(pszValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).pOther as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(pOther)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).pszSRS as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(pszSRS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).psLeftNode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(psLeftNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FilterNode>())).psRightNode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FilterNode),
            "::",
            stringify!(psRightNode)
        )
    );
}
pub type FilterEncodingNode = _FilterNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct attributeBindingObj {
    pub item: *mut ::std::os::raw::c_char,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_attributeBindingObj() {
    assert_eq!(
        ::std::mem::size_of::<attributeBindingObj>(),
        16usize,
        concat!("Size of: ", stringify!(attributeBindingObj))
    );
    assert_eq!(
        ::std::mem::align_of::<attributeBindingObj>(),
        8usize,
        concat!("Alignment of ", stringify!(attributeBindingObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<attributeBindingObj>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(attributeBindingObj),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<attributeBindingObj>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(attributeBindingObj),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelPathObj {
    pub path: multipointObj,
    pub bounds: shapeObj,
    pub angles: *mut f64,
}
#[test]
fn bindgen_test_layout_labelPathObj() {
    assert_eq!(
        ::std::mem::size_of::<labelPathObj>(),
        136usize,
        concat!("Size of: ", stringify!(labelPathObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelPathObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelPathObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelPathObj>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelPathObj),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelPathObj>())).bounds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(labelPathObj),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelPathObj>())).angles as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(labelPathObj),
            "::",
            stringify!(angles)
        )
    );
}
#[doc = "The :ref:`FONTSET <fontset>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fontSetObj {
    #[doc = "< The filename of the fonset"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = "< The number of fonts in the fontset"]
    pub numfonts: ::std::os::raw::c_int,
    #[doc = "< Key, value pairs of font name and font file"]
    pub fonts: hashTableObj,
    pub map: *mut mapObj,
}
#[test]
fn bindgen_test_layout_fontSetObj() {
    assert_eq!(
        ::std::mem::size_of::<fontSetObj>(),
        40usize,
        concat!("Size of: ", stringify!(fontSetObj))
    );
    assert_eq!(
        ::std::mem::align_of::<fontSetObj>(),
        8usize,
        concat!("Alignment of ", stringify!(fontSetObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fontSetObj>())).filename as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fontSetObj),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fontSetObj>())).numfonts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fontSetObj),
            "::",
            stringify!(numfonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fontSetObj>())).fonts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fontSetObj),
            "::",
            stringify!(fonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fontSetObj>())).map as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fontSetObj),
            "::",
            stringify!(map)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listNode {
    pub shape: shapeObj,
    pub next: *mut listNode,
    pub tailifhead: *mut listNode,
}
#[test]
fn bindgen_test_layout_listNode() {
    assert_eq!(
        ::std::mem::size_of::<listNode>(),
        128usize,
        concat!("Size of: ", stringify!(listNode))
    );
    assert_eq!(
        ::std::mem::align_of::<listNode>(),
        8usize,
        concat!("Alignment of ", stringify!(listNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<listNode>())).shape as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(listNode),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<listNode>())).next as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(listNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<listNode>())).tailifhead as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(listNode),
            "::",
            stringify!(tailifhead)
        )
    );
}
pub type featureListNodeObj = listNode;
pub type featureListNodeObjPtr = *mut featureListNodeObj;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct paletteObj {
    pub colors: [colorObj; 255usize],
    pub colorvalue: [::std::os::raw::c_int; 255usize],
    pub numcolors: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_paletteObj() {
    assert_eq!(
        ::std::mem::size_of::<paletteObj>(),
        5104usize,
        concat!("Size of: ", stringify!(paletteObj))
    );
    assert_eq!(
        ::std::mem::align_of::<paletteObj>(),
        4usize,
        concat!("Alignment of ", stringify!(paletteObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteObj>())).colors as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteObj),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteObj>())).colorvalue as *const _ as usize },
        4080usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteObj),
            "::",
            stringify!(colorvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paletteObj>())).numcolors as *const _ as usize },
        5100usize,
        concat!(
            "Offset of field: ",
            stringify!(paletteObj),
            "::",
            stringify!(numcolors)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tokenValueObj {
    pub dblval: f64,
    pub intval: ::std::os::raw::c_int,
    pub strval: *mut ::std::os::raw::c_char,
    pub tmval: tm,
    pub shpval: *mut shapeObj,
    pub bindval: attributeBindingObj,
}
#[test]
fn bindgen_test_layout_tokenValueObj() {
    assert_eq!(
        ::std::mem::size_of::<tokenValueObj>(),
        56usize,
        concat!("Size of: ", stringify!(tokenValueObj))
    );
    assert_eq!(
        ::std::mem::align_of::<tokenValueObj>(),
        8usize,
        concat!("Alignment of ", stringify!(tokenValueObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).dblval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(dblval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).intval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(intval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).strval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(strval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).tmval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(tmval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).shpval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(shpval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenValueObj>())).bindval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenValueObj),
            "::",
            stringify!(bindval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tokenListNode {
    pub token: ::std::os::raw::c_int,
    pub tokenval: tokenValueObj,
    pub tokensrc: *mut ::std::os::raw::c_char,
    pub next: *mut tokenListNode,
    pub tailifhead: *mut tokenListNode,
}
#[test]
fn bindgen_test_layout_tokenListNode() {
    assert_eq!(
        ::std::mem::size_of::<tokenListNode>(),
        88usize,
        concat!("Size of: ", stringify!(tokenListNode))
    );
    assert_eq!(
        ::std::mem::align_of::<tokenListNode>(),
        8usize,
        concat!("Alignment of ", stringify!(tokenListNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenListNode>())).token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenListNode),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenListNode>())).tokenval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenListNode),
            "::",
            stringify!(tokenval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenListNode>())).tokensrc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenListNode),
            "::",
            stringify!(tokensrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenListNode>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenListNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tokenListNode>())).tailifhead as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tokenListNode),
            "::",
            stringify!(tailifhead)
        )
    );
}
pub type tokenListNodeObj = tokenListNode;
pub type tokenListNodeObjPtr = *mut tokenListNodeObj;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct expressionObj {
    pub string: *mut ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub tokens: tokenListNodeObjPtr,
    pub curtoken: tokenListNodeObjPtr,
    pub regex: ms_regex_t,
    pub compiled: ::std::os::raw::c_int,
    pub native_string: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_expressionObj() {
    assert_eq!(
        ::std::mem::size_of::<expressionObj>(),
        56usize,
        concat!("Size of: ", stringify!(expressionObj))
    );
    assert_eq!(
        ::std::mem::align_of::<expressionObj>(),
        8usize,
        concat!("Alignment of ", stringify!(expressionObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).tokens as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).curtoken as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(curtoken)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).regex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(regex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).compiled as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(compiled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<expressionObj>())).native_string as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(expressionObj),
            "::",
            stringify!(native_string)
        )
    );
}
#[doc = "The :ref:`CLUSTER <cluster>` object. See :ref:`RFC 69 <rfc69>`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clusterObj {
    #[doc = "< Maximum distance between clusters - see :ref:`MAXDISTANCE <mapfile-cluster-maxdistance>`"]
    pub maxdistance: f64,
    #[doc = "< The buffer size around the selection area - see :ref:`BUFFER <mapfile-cluster-buffer>`"]
    pub buffer: f64,
    #[doc = "< The type of the cluster region (rectangle or ellipse) - see :ref:`REGION <mapfile-cluster-region>`"]
    pub region: *mut ::std::os::raw::c_char,
    pub group: expressionObj,
    pub filter: expressionObj,
}
#[test]
fn bindgen_test_layout_clusterObj() {
    assert_eq!(
        ::std::mem::size_of::<clusterObj>(),
        136usize,
        concat!("Size of: ", stringify!(clusterObj))
    );
    assert_eq!(
        ::std::mem::align_of::<clusterObj>(),
        8usize,
        concat!("Alignment of ", stringify!(clusterObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterObj>())).maxdistance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterObj),
            "::",
            stringify!(maxdistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterObj>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterObj),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterObj>())).region as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterObj),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterObj>())).group as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterObj),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterObj>())).filter as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterObj),
            "::",
            stringify!(filter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct joinObj {
    pub name: *mut ::std::os::raw::c_char,
    pub items: *mut *mut ::std::os::raw::c_char,
    pub values: *mut *mut ::std::os::raw::c_char,
    pub numitems: ::std::os::raw::c_int,
    pub table: *mut ::std::os::raw::c_char,
    pub from: *mut ::std::os::raw::c_char,
    pub to: *mut ::std::os::raw::c_char,
    pub joininfo: *mut ::std::os::raw::c_void,
    pub header: *mut ::std::os::raw::c_char,
    pub footer: *mut ::std::os::raw::c_char,
    pub _template: *mut ::std::os::raw::c_char,
    pub type_: MS_JOIN_TYPE,
    pub connection: *mut ::std::os::raw::c_char,
    pub connectiontype: MS_JOIN_CONNECTION_TYPE,
}
#[test]
fn bindgen_test_layout_joinObj() {
    assert_eq!(
        ::std::mem::size_of::<joinObj>(),
        112usize,
        concat!("Size of: ", stringify!(joinObj))
    );
    assert_eq!(
        ::std::mem::align_of::<joinObj>(),
        8usize,
        concat!("Alignment of ", stringify!(joinObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).items as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).numitems as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(numitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).from as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).to as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).joininfo as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(joininfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).header as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).footer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>()))._template as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(_template)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).type_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).connection as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<joinObj>())).connectiontype as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(joinObj),
            "::",
            stringify!(connectiontype)
        )
    );
}
#[doc = "The :ref:`OUTPUTFORMAT <outputformat>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct outputFormatObj {
    pub refcount: ::std::os::raw::c_int,
    pub formatoptions: *mut *mut ::std::os::raw::c_char,
    pub vtable: *mut rendererVTableObj,
    pub device: *mut ::std::os::raw::c_void,
    #[doc = "The number of option values set on this format - can be used to"]
    #[doc = "iterate over the options array in conjunction with :func:`outputFormatObj.getOptionAt`"]
    pub numformatoptions: ::std::os::raw::c_int,
    #[doc = "< See :ref:`NAME <mapfile-outputformat-name>`"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`MIMETYPE <mapfile-outputformat-mimetype>`"]
    pub mimetype: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`DRIVER <mapfile-outputformat-driver>`"]
    pub driver: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`EXTENSION <mapfile-outputformat-extension>`"]
    pub extension: *mut ::std::os::raw::c_char,
    #[doc = "< A :ref:`render mode constant<mapfile-constants-render>` - normally set internally based on the driver and some other setting in the constructor."]
    pub renderer: ::std::os::raw::c_int,
    #[doc = "< An :ref:`Image mode constant<mapfile-constants-imagemode>` - see :ref:`IMAGEMODE <mapfile-outputformat-imagemode>`"]
    pub imagemode: ::std::os::raw::c_int,
    #[doc = "< See :ref:`TRANSPARENT <mapfile-outputformat-transparent>`"]
    pub transparent: ::std::os::raw::c_int,
    #[doc = "< The number of bands in the raster, normally set via the BAND_COUNT formatoption - this field should be considered read-only"]
    #[doc = "< Only used for the \"raw\" modes, MS_IMAGEMODE_BYTE, MS_IMAGEMODE_INT16, and MS_IMAGEMODE_FLOAT32"]
    pub bands: ::std::os::raw::c_int,
    #[doc = "< Boolean value indicating if the format is in the Mapfile"]
    pub inmapfile: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_outputFormatObj() {
    assert_eq!(
        ::std::mem::size_of::<outputFormatObj>(),
        96usize,
        concat!("Size of: ", stringify!(outputFormatObj))
    );
    assert_eq!(
        ::std::mem::align_of::<outputFormatObj>(),
        8usize,
        concat!("Alignment of ", stringify!(outputFormatObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).formatoptions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(formatoptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).vtable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).device as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<outputFormatObj>())).numformatoptions as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(numformatoptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).mimetype as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(mimetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).driver as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).extension as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).renderer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(renderer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).imagemode as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(imagemode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).transparent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(transparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).bands as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(bands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<outputFormatObj>())).inmapfile as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(outputFormatObj),
            "::",
            stringify!(inmapfile)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queryObj {
    pub type_: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub layer: ::std::os::raw::c_int,
    pub point: pointObj,
    pub buffer: f64,
    pub maxresults: ::std::os::raw::c_int,
    pub rect: rectObj,
    pub shape: *mut shapeObj,
    pub shapeindex: ::std::os::raw::c_long,
    pub tileindex: ::std::os::raw::c_long,
    pub clear_resultcache: ::std::os::raw::c_int,
    pub maxfeatures: ::std::os::raw::c_int,
    pub startindex: ::std::os::raw::c_int,
    pub only_cache_result_count: ::std::os::raw::c_int,
    pub filter: expressionObj,
    pub filteritem: *mut ::std::os::raw::c_char,
    pub slayer: ::std::os::raw::c_int,
    pub cache_shapes: ::std::os::raw::c_int,
    pub max_cached_shape_count: ::std::os::raw::c_int,
    pub max_cached_shape_ram_amount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_queryObj() {
    assert_eq!(
        ::std::mem::size_of::<queryObj>(),
        216usize,
        concat!("Size of: ", stringify!(queryObj))
    );
    assert_eq!(
        ::std::mem::align_of::<queryObj>(),
        8usize,
        concat!("Alignment of ", stringify!(queryObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).layer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).point as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).maxresults as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(maxresults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).rect as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).shape as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).shapeindex as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(shapeindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).tileindex as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(tileindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).clear_resultcache as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(clear_resultcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).maxfeatures as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(maxfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).startindex as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(startindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<queryObj>())).only_cache_result_count as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(only_cache_result_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).filter as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).filteritem as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(filteritem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).slayer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(slayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).cache_shapes as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(cache_shapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryObj>())).max_cached_shape_count as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(max_cached_shape_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<queryObj>())).max_cached_shape_ram_amount as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(queryObj),
            "::",
            stringify!(max_cached_shape_ram_amount)
        )
    );
}
#[doc = "The :ref:`QUERYMAP <querymap>` object."]
#[doc = "Instances of querymapObj are always are always embedded inside the :class:`mapObj`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct queryMapObj {
    #[doc = "< Reference to parent :class:`mapObj`"]
    pub map: *mut mapObj,
    #[doc = "< See :ref:`SIZE <mapfile-querymap-size>`"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< See :ref:`SIZE <mapfile-querymap-size>`"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< See :ref:`STATUS <mapfile-querymap-status>`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< ``HILITE``, ``SELECTED`` or ``NORMAL`` - see :ref:`STYLE <mapfile-querymap-style>`"]
    pub style: ::std::os::raw::c_int,
    #[doc = "< See :ref:`COLOR <mapfile-querymap-color>`"]
    pub color: colorObj,
}
#[test]
fn bindgen_test_layout_queryMapObj() {
    assert_eq!(
        ::std::mem::size_of::<queryMapObj>(),
        40usize,
        concat!("Size of: ", stringify!(queryMapObj))
    );
    assert_eq!(
        ::std::mem::align_of::<queryMapObj>(),
        8usize,
        concat!("Alignment of ", stringify!(queryMapObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).style as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<queryMapObj>())).color as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(queryMapObj),
            "::",
            stringify!(color)
        )
    );
}
#[doc = "The :ref:`WEB <web>` object."]
#[doc = "Has no other existence than as an attribute of a :class:`mapObj`."]
#[doc = "Serves as a container for various run-time web application definitions like temporary file paths, template paths, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct webObj {
    #[doc = "< Metadata hash table - see :ref:`METADATA <mapfile-web-metadata>`"]
    pub metadata: hashTableObj,
    #[doc = "< See :ref:`VALIDATION <mapfile-web-validation>`"]
    pub validation: hashTableObj,
    #[doc = "< Reference to parent :class:`mapObj`"]
    pub map: *mut mapObj,
    #[doc = "< Filesystem path to temporary image location - see :ref:`IMAGEPATH <mapfile-web-imagepath>`"]
    pub imagepath: *mut ::std::os::raw::c_char,
    #[doc = "< URL to temporary image location - see :ref:`IMAGEURL <mapfile-web-imageurl>`"]
    pub imageurl: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`TEMPPATH <mapfile-web-temppath>`"]
    pub temppath: *mut ::std::os::raw::c_char,
    #[doc = "< Path to header document - see :ref:`HEADER <mapfile-web-header>`"]
    pub header: *mut ::std::os::raw::c_char,
    #[doc = "< Path to footer document - see :ref:`FOOTER <mapfile-web-footer>`"]
    pub footer: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`EMPTY <mapfile-web-empty>`"]
    pub empty: *mut ::std::os::raw::c_char,
    #[doc = "< Error handling - see :ref:`ERROR <mapfile-web-error>`"]
    pub error: *mut ::std::os::raw::c_char,
    #[doc = "< Maximum map scale - see :ref:`MINSCALEDENOM <mapfile-web-minscaledenom>`"]
    pub minscaledenom: f64,
    #[doc = "< Minimum map scale - see :ref:`MAXSCALEDENOM <mapfile-web-maxscaledenom>`"]
    pub maxscaledenom: f64,
    #[doc = "< See :ref:`MINTEMPLATE <mapfile-web-mintemplate>`"]
    pub mintemplate: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`MAXTEMPLATE <mapfile-web-maxtemplate>`"]
    pub maxtemplate: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`QUERYFORMAT <mapfile-web-queryformat>` /* what format is the query to be returned, given as a MIME type */"]
    pub queryformat: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`LEGENDFORMAT <mapfile-web-legendformat>`"]
    pub legendformat: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`BROWSEFORMAT <mapfile-web-browseformat>`"]
    pub browseformat: *mut ::std::os::raw::c_char,
    pub _template: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_webObj() {
    assert_eq!(
        ::std::mem::size_of::<webObj>(),
        160usize,
        concat!("Size of: ", stringify!(webObj))
    );
    assert_eq!(
        ::std::mem::align_of::<webObj>(),
        8usize,
        concat!("Alignment of ", stringify!(webObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).metadata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).validation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(validation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).map as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).imagepath as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(imagepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).imageurl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(imageurl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).temppath as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(temppath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).header as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).footer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).empty as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).error as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).minscaledenom as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(minscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).maxscaledenom as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(maxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).mintemplate as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(mintemplate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).maxtemplate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(maxtemplate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).queryformat as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(queryformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).legendformat as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(legendformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>())).browseformat as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(browseformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<webObj>()))._template as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(webObj),
            "::",
            stringify!(_template)
        )
    );
}
#[doc = "The :ref:`STYLE <style>` object. An instance of styleObj is associated with one instance of :class:`classObj`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct styleObj {
    pub _geomtransform: expressionObj,
    pub scalefactor: f64,
    pub bindings: [attributeBindingObj; 12usize],
    pub numbindings: ::std::os::raw::c_int,
    pub exprBindings: [expressionObj; 12usize],
    pub nexprbindings: ::std::os::raw::c_int,
    #[doc = "< number of references to this object"]
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< Name of the style's symbol - see :ref:`symbolname <mapfile-style-symbol>`"]
    pub symbolname: *mut ::std::os::raw::c_char,
    #[doc = "< Number of elements in the pattern attribute"]
    pub patternlength: ::std::os::raw::c_int,
    #[doc = "< List of on, off values to define a dash pattern for line work (lines, polygon outlines, hatch lines)"]
    pub pattern: [f64; 10usize],
    #[doc = "< Angle, given in degrees, to draw the line work, default is 0, for symbols of Type HATCH, this is the angle of the"]
    #[doc = "< hatched lines - see :ref:`ANGLE <mapfile-style-angle>`"]
    pub angle: f64,
    #[doc = "< If the angle is set to ``AUTO`` - see :ref:`ANGLE <mapfile-style-angle>`"]
    pub autoangle: ::std::os::raw::c_int,
    #[doc = "< See :ref:`ANTIALIAS <mapfile-style-antialias>`"]
    pub antialiased: ::std::os::raw::c_int,
    #[doc = "< Foreground or fill pen color - see :ref:`COLOR <mapfile-style-color>`"]
    pub color: colorObj,
    #[doc = "< Outline pen color - see :ref:`OUTLINECOLOR <mapfile-style-outlinecolor>`"]
    pub outlinecolor: colorObj,
    #[doc = "< See :ref:`OPACITY <mapfile-style-opacity>`"]
    pub opacity: ::std::os::raw::c_int,
    #[doc = "< Minimum color in the :ref:`COLORRANGE <mapfile-style-colorrange>`"]
    pub mincolor: colorObj,
    #[doc = "< Maximum color in the :ref:`COLORRANGE <mapfile-style-colorrange>`"]
    pub maxcolor: colorObj,
    #[doc = "< related to color ranges"]
    pub minvalue: f64,
    #[doc = "< related to color ranges"]
    pub maxvalue: f64,
    #[doc = "< Attribute/field that stores the values for the Color Range Mapping  - see :ref:`RANGEITEM <mapfile-style-rangeitem>`"]
    pub rangeitem: *mut ::std::os::raw::c_char,
    #[doc = "< The index of the range item - see :ref:`RANGEITEM <mapfile-style-rangeitem>`"]
    pub rangeitemindex: ::std::os::raw::c_int,
    #[doc = "< The index within the map symbolset of the style's symbol - see :ref:`SYMBOL <mapfile-style-symbol>`"]
    pub symbol: ::std::os::raw::c_int,
    #[doc = "< Pixel width of the style's pen or symbol - see :ref:`SIZE <mapfile-style-size>`"]
    pub size: f64,
    #[doc = "< Minimum pen or symbol width for scaling styles - see :ref:`MINSIZE <mapfile-style-minsize>`"]
    pub minsize: f64,
    #[doc = "< Maximum pen or symbol width for scaling - see :ref:`MAXSIZE <mapfile-style-maxsize>`"]
    pub maxsize: f64,
    #[doc = "< See :ref:`GAP <mapfile-style-gap>` - moved from symbolObj in version 6.0"]
    pub gap: f64,
    #[doc = "< See :ref:`INITIALGAP <mapfile-style-initialgap>`"]
    pub initialgap: f64,
    #[doc = "< See :ref:`LINECAP <mapfile-style-linecap>`"]
    pub linecap: ::std::os::raw::c_int,
    #[doc = "< See :ref:`LINEJOIN <mapfile-style-linejoin>` - moved from symbolObj in version 6.0"]
    pub linejoin: ::std::os::raw::c_int,
    #[doc = "< See :ref:`LINEJOINMAXSIZE <mapfile-style-linejoinmaxsize>` - moved from symbolObj in version 6.0"]
    pub linejoinmaxsize: f64,
    #[doc = "< Width refers to the thickness of line work drawn, in pixels - default is 1,"]
    #[doc = "< for symbols of type ``HATCH``, the with is how thick the hatched lines are - see :ref:`WIDTH <mapfile-style-width>`"]
    pub width: f64,
    #[doc = "< See :ref:`OUTLINEWIDTH <mapfile-style-outlinewidth>`"]
    pub outlinewidth: f64,
    #[doc = "< Minimum width of the symbol - see :ref:`MINWIDTH <mapfile-style-minwidth>`"]
    pub minwidth: f64,
    #[doc = "< Maximum width of the symbol - see :ref:`MAXWIDTH <mapfile-style-maxwidth>`"]
    pub maxwidth: f64,
    #[doc = "< Draw with pen or symbol offset from map data, for shadows, hollow symbols, etc - see :ref:`OFFSET <mapfile-style-offset>`"]
    pub offsetx: f64,
    #[doc = "< Draw with pen or symbol offset from map data, for shadows, hollow symbols, etc - see :ref:`OFFSET <mapfile-style-offset>`"]
    pub offsety: f64,
    #[doc = "< Specifies the radius/distance - see :ref:`POLAROFFSET <mapfile-style-polaroffset>`"]
    pub polaroffsetpixel: f64,
    #[doc = "< Specified the angle - see :ref:`POLAROFFSET <mapfile-style-polaroffset>`"]
    pub polaroffsetangle: f64,
    #[doc = "< See :ref:`MINSCALEDENOM <mapfile-style-minscaledenom>`"]
    pub minscaledenom: f64,
    #[doc = "< See :ref:`MAXSCALEDENOM <mapfile-style-maxscaledenom>`"]
    pub maxscaledenom: f64,
    #[doc = "< Supersedes class's :ref:`SIZEUNITS <mapfile-layer-sizeunits>` to allow fine-grained sizing for improved SLD (RFC 124)"]
    pub sizeunits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_styleObj() {
    assert_eq!(
        ::std::mem::size_of::<styleObj>(),
        1304usize,
        concat!("Size of: ", stringify!(styleObj))
    );
    assert_eq!(
        ::std::mem::align_of::<styleObj>(),
        8usize,
        concat!("Alignment of ", stringify!(styleObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>()))._geomtransform as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(_geomtransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).scalefactor as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(scalefactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).bindings as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).numbindings as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(numbindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).exprBindings as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(exprBindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).nexprbindings as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(nexprbindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).refcount as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).symbolname as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(symbolname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).patternlength as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(patternlength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).pattern as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).angle as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).autoangle as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(autoangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).antialiased as *const _ as usize },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(antialiased)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).color as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).outlinecolor as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).opacity as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(opacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).mincolor as *const _ as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(mincolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).maxcolor as *const _ as usize },
        1108usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(maxcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).minvalue as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(minvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).maxvalue as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(maxvalue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).rangeitem as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(rangeitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).rangeitemindex as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(rangeitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).symbol as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).size as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).minsize as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(minsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).maxsize as *const _ as usize },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).gap as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).initialgap as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(initialgap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).linecap as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(linecap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).linejoin as *const _ as usize },
        1204usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(linejoin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).linejoinmaxsize as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(linejoinmaxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).width as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).outlinewidth as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(outlinewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).minwidth as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(minwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).maxwidth as *const _ as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).offsetx as *const _ as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(offsetx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).offsety as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(offsety)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).polaroffsetpixel as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(polaroffsetpixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).polaroffsetangle as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(polaroffsetangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).minscaledenom as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(minscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).maxscaledenom as *const _ as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(maxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<styleObj>())).sizeunits as *const _ as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(styleObj),
            "::",
            stringify!(sizeunits)
        )
    );
}
#[doc = "The :ref:`LEADER <leader>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelLeaderObj {
    pub styles: *mut *mut styleObj,
    pub maxstyles: ::std::os::raw::c_int,
    #[doc = "< Number of styles used"]
    pub numstyles: ::std::os::raw::c_int,
    #[doc = "< See :ref:`MAXDISTANCE <mapfile-leader-maxdistance>`"]
    pub maxdistance: ::std::os::raw::c_int,
    #[doc = "< See :ref:`GRIDSTEP <mapfile-leader-gridstep>`"]
    pub gridstep: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_labelLeaderObj() {
    assert_eq!(
        ::std::mem::size_of::<labelLeaderObj>(),
        24usize,
        concat!("Size of: ", stringify!(labelLeaderObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelLeaderObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelLeaderObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelLeaderObj>())).styles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelLeaderObj),
            "::",
            stringify!(styles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelLeaderObj>())).maxstyles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(labelLeaderObj),
            "::",
            stringify!(maxstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelLeaderObj>())).numstyles as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(labelLeaderObj),
            "::",
            stringify!(numstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelLeaderObj>())).maxdistance as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(labelLeaderObj),
            "::",
            stringify!(maxdistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelLeaderObj>())).gridstep as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(labelLeaderObj),
            "::",
            stringify!(gridstep)
        )
    );
}
#[doc = "The :ref:`LABEL <label>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelObj {
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< Name of TrueType font  see :ref:`FONT <mapfile-label-font>`"]
    pub font: *mut ::std::os::raw::c_char,
    #[doc = "< Foreground color - see :ref:`COLOR <mapfile-label-color>`"]
    pub color: colorObj,
    #[doc = "< Color of one point outline - see :ref:`OUTLINECOLOR <mapfile-label-outlinecolor>`"]
    pub outlinecolor: colorObj,
    #[doc = "< See :ref:`OUTLINEWIDTH <mapfile-label-outlinewidth>`"]
    pub outlinewidth: ::std::os::raw::c_int,
    #[doc = "< See :ref:`SHADOWCOLOR <mapfile-label-shadowcolor>`"]
    pub shadowcolor: colorObj,
    #[doc = "< See :ref:`SHADOWSIZE <mapfile-label-shadowsize>`"]
    pub shadowsizex: ::std::os::raw::c_int,
    #[doc = "< See :ref:`SHADOWSIZE <mapfile-label-shadowsize>`"]
    pub shadowsizey: ::std::os::raw::c_int,
    #[doc = "< Annotation height in pixels - see :ref:`SIZE <mapfile-label-size>`"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< Minimum height in pixels - see :ref:`MINSIZE <mapfile-label-minsize>`"]
    pub minsize: ::std::os::raw::c_int,
    #[doc = "< Maximum height in pixels for scaled labels. See :ref:`MAXSIZE <mapfile-label-maxsize>`"]
    pub maxsize: ::std::os::raw::c_int,
    #[doc = "< See :ref:`POSTION <mapfile-label-position>`"]
    pub position: ::std::os::raw::c_int,
    #[doc = "< Horizontal offset of label - see :ref:`OFFSET <mapfile-label-offset>`"]
    pub offsetx: ::std::os::raw::c_int,
    #[doc = "< Vertical offset of label - see :ref:`OFFSET <mapfile-label-offset>`"]
    pub offsety: ::std::os::raw::c_int,
    #[doc = "< See :ref:`ANGLE <mapfile-label-angle>`"]
    pub angle: f64,
    #[doc = "< One of :data:`AUTO` :data:`AUTO2`, or :data:`FOLLOW` - see :ref:`ANGLE <mapfile-label-angle>`"]
    pub anglemode: MS_POSITIONS_ENUM,
    #[doc = "< Space to reserve around a label (padding) - see :ref:`BUFFER <mapfile-label-buffer>`"]
    pub buffer: ::std::os::raw::c_int,
    #[doc = "< See :ref:`ALIGN <mapfile-label-align>`"]
    pub align: ::std::os::raw::c_int,
    #[doc = "< See :ref:`WRAP <mapfile-label-wrap>`"]
    pub wrap: ::std::os::raw::c_char,
    #[doc = "< See :ref:`MAXLENGTH <mapfile-label-maxlength>`"]
    pub maxlength: ::std::os::raw::c_int,
    #[doc = "< Cached size of a single space character used for label text alignment of rfc40"]
    pub space_size_10: f64,
    #[doc = "Minimum feature size (in pixels) to label, features of this size or greater will be"]
    #[doc = "labeled - see :ref:`MINFEATURESIZE  <mapfile-label-minfeaturesize>`"]
    pub minfeaturesize: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_TRUE` or :data:`MS_FALSE`"]
    pub autominfeaturesize: ::std::os::raw::c_int,
    #[doc = "< See :ref:`MINSCALEDENOM  <mapfile-label-minscaledenom>`"]
    pub minscaledenom: f64,
    #[doc = "< See :ref:`MAXSCALEDENOM  <mapfile-label-maxscaledenom>`"]
    pub maxscaledenom: f64,
    #[doc = "< Minimum distance in pixels between duplicate labels - see :ref:`MINDISTANCE <mapfile-label-mindistance>`"]
    pub mindistance: ::std::os::raw::c_int,
    #[doc = "< See :ref:`REPEATDISTANCE <mapfile-label-repeatdistance>`"]
    pub repeatdistance: ::std::os::raw::c_int,
    #[doc = "< See :ref:`MAXOVERLAPANGLE <mapfile-label-maxoverlapangle>`"]
    pub maxoverlapangle: f64,
    #[doc = "Indicates if labels can run off the edge of an image, either :data:`MS_TRUE`"]
    #[doc = "or :data:`MS_FALSE` (default) - see :ref:`PARTIALS <mapfile-label-partials>`"]
    pub partials: ::std::os::raw::c_int,
    #[doc = "< Indicates if labels **must** be drawn - see :ref:`FORCE <mapfile-label-force>`"]
    pub force: ::std::os::raw::c_int,
    #[doc = "< Supported encoding format to be used for labels - see :ref:`ENCODING <mapfile-label-encoding>`"]
    pub encoding: *mut ::std::os::raw::c_char,
    #[doc = "< Priority level 1 to :data:`MS_MAX_LABEL_PRIORITY`, default=1 - see :ref:`PRIORITY <mapfile-label-priority>`"]
    pub priority: ::std::os::raw::c_int,
    #[doc = "< The number of styles associated with the label"]
    pub numstyles: ::std::os::raw::c_int,
    #[doc = "< Supersedes class's sizeunits, defaults to :data:`MS_INHERIT`."]
    pub sizeunits: ::std::os::raw::c_int,
    pub styles: *mut *mut styleObj,
    pub maxstyles: ::std::os::raw::c_int,
    pub expression: expressionObj,
    pub text: expressionObj,
    pub leader: *mut labelLeaderObj,
    pub bindings: [attributeBindingObj; 12usize],
    pub numbindings: ::std::os::raw::c_int,
    pub exprBindings: [expressionObj; 12usize],
    pub nexprbindings: ::std::os::raw::c_int,
    pub scalefactor: f64,
}
#[test]
fn bindgen_test_layout_labelObj() {
    assert_eq!(
        ::std::mem::size_of::<labelObj>(),
        1240usize,
        concat!("Size of: ", stringify!(labelObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).font as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).color as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).outlinecolor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).outlinewidth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(outlinewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).shadowcolor as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(shadowcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).shadowsizex as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(shadowsizex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).shadowsizey as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(shadowsizey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).minsize as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(minsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).maxsize as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).position as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).offsetx as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(offsetx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).offsety as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(offsety)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).angle as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(angle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).anglemode as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(anglemode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).buffer as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).wrap as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(wrap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).maxlength as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(maxlength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).space_size_10 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(space_size_10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).minfeaturesize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(minfeaturesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).autominfeaturesize as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(autominfeaturesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).minscaledenom as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(minscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).maxscaledenom as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(maxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).mindistance as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(mindistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).repeatdistance as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(repeatdistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).maxoverlapangle as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(maxoverlapangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).partials as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(partials)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).force as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(force)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).encoding as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).priority as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).numstyles as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(numstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).sizeunits as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(sizeunits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).styles as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(styles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).maxstyles as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(maxstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).expression as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(expression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).text as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).leader as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).bindings as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).numbindings as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(numbindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).exprBindings as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(exprBindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).nexprbindings as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(nexprbindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelObj>())).scalefactor as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(labelObj),
            "::",
            stringify!(scalefactor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label_bounds {
    pub poly: *mut lineObj,
    pub bbox: rectObj,
}
#[test]
fn bindgen_test_layout_label_bounds() {
    assert_eq!(
        ::std::mem::size_of::<label_bounds>(),
        40usize,
        concat!("Size of: ", stringify!(label_bounds))
    );
    assert_eq!(
        ::std::mem::align_of::<label_bounds>(),
        8usize,
        concat!("Alignment of ", stringify!(label_bounds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_bounds>())).poly as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(label_bounds),
            "::",
            stringify!(poly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_bounds>())).bbox as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(label_bounds),
            "::",
            stringify!(bbox)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textSymbolObj {
    pub label: *mut labelObj,
    pub annotext: *mut ::std::os::raw::c_char,
    pub scalefactor: f64,
    pub resolutionfactor: f64,
    pub annopoint: pointObj,
    pub rotation: f64,
    pub textpath: *mut textPathObj,
    pub style_bounds: *mut *mut label_bounds,
}
#[test]
fn bindgen_test_layout_textSymbolObj() {
    assert_eq!(
        ::std::mem::size_of::<textSymbolObj>(),
        88usize,
        concat!("Size of: ", stringify!(textSymbolObj))
    );
    assert_eq!(
        ::std::mem::align_of::<textSymbolObj>(),
        8usize,
        concat!("Alignment of ", stringify!(textSymbolObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).annotext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(annotext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).scalefactor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(scalefactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).resolutionfactor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(resolutionfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).annopoint as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(annopoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).rotation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).textpath as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(textpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textSymbolObj>())).style_bounds as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(textSymbolObj),
            "::",
            stringify!(style_bounds)
        )
    );
}
#[doc = " The :ref:`CLASS <class>` object. Used for symbolization and classification information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct classObj {
    #[doc = "< see :ref:`METADATA <mapfile-class-metadata>`"]
    pub metadata: hashTableObj,
    #[doc = "< see :ref:`VALIDATION <mapfile-class-validation>`"]
    pub validation: hashTableObj,
    #[doc = "< number of styles for class"]
    pub numstyles: ::std::os::raw::c_int,
    #[doc = "< number of labels for class"]
    pub numlabels: ::std::os::raw::c_int,
    #[doc = "< number of references to this object"]
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< reference to the parent layer"]
    pub layer: *mut layerObj,
    #[doc = "< see :ref:`LEADER <mapfile-class-leader>`"]
    pub leader: *mut labelLeaderObj,
    #[doc = "< :data:`MS_ON` or :data:`MS_OFF` - draw features of this class or do not - see :ref:`STATUS <mapfile-class-status>`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_TRUE` or :data:`MS_FALSE` use :data:`MS_TRUE` if this class should be applied if and only if no other class is applicable"]
    pub isfallback: ::std::os::raw::c_int,
    #[doc = "< See :ref:`NAME <mapfile-class-name>` should be unique within a layer"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`TITLE <mapfile-class-title>`"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`MINSCALEDENOM <mapfile-class-minscaledenom>`"]
    pub minscaledenom: f64,
    #[doc = "< See :ref:`MAXSCALEDENOM <mapfile-CLASS-maxscaledenom>`"]
    pub maxscaledenom: f64,
    #[doc = "< See :ref:`MINFEATURESIZE <mapfile-class-minfeaturesize>` minimum feature size in pixels"]
    pub minfeaturesize: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_TRUE` or :data:`MS_FALSE` - see :ref:`DEBUG <mapfile-class-debug>`"]
    pub debug: ::std::os::raw::c_int,
    #[doc = "< See :ref:`KEYIMAGE <mapfile-class-keyimage>`"]
    pub keyimage: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`GROUP <mapfile-class-group>`"]
    pub group: *mut ::std::os::raw::c_char,
    #[doc = "< Supersedes layer's sizeunits and applies to all styles and labels - see :ref:`LAYER SIZEUNITS <mapfile-layer-sizeunits>`"]
    pub sizeunits: ::std::os::raw::c_int,
    pub _template: *mut ::std::os::raw::c_char,
    pub text: expressionObj,
    pub expression: expressionObj,
    pub labels: *mut *mut labelObj,
    pub maxlabels: ::std::os::raw::c_int,
    pub maxstyles: ::std::os::raw::c_int,
    pub styles: *mut *mut styleObj,
    pub scalefactor: f64,
}
#[test]
fn bindgen_test_layout_classObj() {
    assert_eq!(
        ::std::mem::size_of::<classObj>(),
        288usize,
        concat!("Size of: ", stringify!(classObj))
    );
    assert_eq!(
        ::std::mem::align_of::<classObj>(),
        8usize,
        concat!("Alignment of ", stringify!(classObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).metadata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).validation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(validation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).numstyles as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(numstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).numlabels as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(numlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).refcount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).layer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).leader as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).status as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).isfallback as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(isfallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).name as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).title as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).minscaledenom as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(minscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).maxscaledenom as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(maxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).minfeaturesize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(minfeaturesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).debug as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).keyimage as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(keyimage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).group as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).sizeunits as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(sizeunits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>()))._template as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(_template)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).text as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).expression as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(expression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).labels as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).maxlabels as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(maxlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).maxstyles as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(maxstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).styles as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(styles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<classObj>())).scalefactor as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(classObj),
            "::",
            stringify!(scalefactor)
        )
    );
}
#[doc = "An individual feature label. The labelCacheMemberObj class is associated with labelCacheObj."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelCacheMemberObj {
    #[doc = "< Number of text symbols found in textsymbols"]
    pub numtextsymbols: ::std::os::raw::c_int,
    #[doc = "< The index of the layer of the labelled feature"]
    pub layerindex: ::std::os::raw::c_int,
    #[doc = "< Index of the class of the labelled feature"]
    pub classindex: ::std::os::raw::c_int,
    #[doc = "< Has this label been drawn or not?"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< Corresponding marker (POINT layers only)"]
    pub markerid: ::std::os::raw::c_int,
    #[doc = "< Label point"]
    pub point: pointObj,
    #[doc = "< Bounds of the whole cachePtr. Individual text and symbol sub bounds are found in textsymbols"]
    pub bbox: rectObj,
    #[doc = "< Leader lineObj"]
    pub leaderline: *mut lineObj,
    #[doc = "< Leader rectObj"]
    pub leaderbbox: *mut rectObj,
    pub textsymbols: *mut *mut textSymbolObj,
}
#[test]
fn bindgen_test_layout_labelCacheMemberObj() {
    assert_eq!(
        ::std::mem::size_of::<labelCacheMemberObj>(),
        112usize,
        concat!("Size of: ", stringify!(labelCacheMemberObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelCacheMemberObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelCacheMemberObj))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<labelCacheMemberObj>())).numtextsymbols as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(numtextsymbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).layerindex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(layerindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).classindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(classindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).status as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).markerid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(markerid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).point as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).bbox as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).leaderline as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(leaderline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).leaderbbox as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(leaderbbox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheMemberObj>())).textsymbols as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheMemberObj),
            "::",
            stringify!(textsymbols)
        )
    );
}
#[doc = "An individual marker. The markerCacheMemberObj class is associated with labelCacheObj."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct markerCacheMemberObj {
    #[doc = "< Corresponding label"]
    pub id: ::std::os::raw::c_int,
    #[doc = "< Bounds of the markerCacheMemberObj"]
    pub bounds: rectObj,
}
#[test]
fn bindgen_test_layout_markerCacheMemberObj() {
    assert_eq!(
        ::std::mem::size_of::<markerCacheMemberObj>(),
        40usize,
        concat!("Size of: ", stringify!(markerCacheMemberObj))
    );
    assert_eq!(
        ::std::mem::align_of::<markerCacheMemberObj>(),
        8usize,
        concat!("Alignment of ", stringify!(markerCacheMemberObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<markerCacheMemberObj>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(markerCacheMemberObj),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<markerCacheMemberObj>())).bounds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(markerCacheMemberObj),
            "::",
            stringify!(bounds)
        )
    );
}
#[doc = "A cache slot to hold labels grouped by priority"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelCacheSlotObj {
    #[doc = "< Number of label members"]
    pub numlabels: ::std::os::raw::c_int,
    #[doc = "< TODO"]
    pub cachesize: ::std::os::raw::c_int,
    #[doc = "< Number of marker members"]
    pub nummarkers: ::std::os::raw::c_int,
    #[doc = "< TODO"]
    pub markercachesize: ::std::os::raw::c_int,
    pub labels: *mut labelCacheMemberObj,
    pub markers: *mut markerCacheMemberObj,
}
#[test]
fn bindgen_test_layout_labelCacheSlotObj() {
    assert_eq!(
        ::std::mem::size_of::<labelCacheSlotObj>(),
        32usize,
        concat!("Size of: ", stringify!(labelCacheSlotObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelCacheSlotObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelCacheSlotObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheSlotObj>())).numlabels as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(numlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheSlotObj>())).cachesize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(cachesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheSlotObj>())).nummarkers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(nummarkers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<labelCacheSlotObj>())).markercachesize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(markercachesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheSlotObj>())).labels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheSlotObj>())).markers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheSlotObj),
            "::",
            stringify!(markers)
        )
    );
}
#[doc = "Set of a map's cached labels. Has no other existence other than as a labelcache"]
#[doc = "attribute of a mapObj. Associated with labelCacheMemberObj and markerCacheMemberObj."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct labelCacheObj {
    #[doc = "< Number of rendered labels"]
    pub num_rendered_members: ::std::os::raw::c_int,
    pub slots: [labelCacheSlotObj; 10usize],
    pub gutter: ::std::os::raw::c_int,
    pub rendered_text_symbols: *mut *mut labelCacheMemberObj,
    pub num_allocated_rendered_members: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_labelCacheObj() {
    assert_eq!(
        ::std::mem::size_of::<labelCacheObj>(),
        352usize,
        concat!("Size of: ", stringify!(labelCacheObj))
    );
    assert_eq!(
        ::std::mem::align_of::<labelCacheObj>(),
        8usize,
        concat!("Alignment of ", stringify!(labelCacheObj))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<labelCacheObj>())).num_rendered_members as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheObj),
            "::",
            stringify!(num_rendered_members)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheObj>())).slots as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheObj),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<labelCacheObj>())).gutter as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheObj),
            "::",
            stringify!(gutter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<labelCacheObj>())).rendered_text_symbols as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheObj),
            "::",
            stringify!(rendered_text_symbols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<labelCacheObj>())).num_allocated_rendered_members as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(labelCacheObj),
            "::",
            stringify!(num_allocated_rendered_members)
        )
    );
}
#[doc = "The result object is a handle, of sorts, for a feature of the layer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resultObj {
    pub shape: *mut shapeObj,
    #[doc = "< The shape index of the result"]
    pub shapeindex: ::std::os::raw::c_long,
    #[doc = "< The tile index of the result"]
    pub tileindex: ::std::os::raw::c_int,
    #[doc = "< The index of the result"]
    pub resultindex: ::std::os::raw::c_int,
    #[doc = "< The class index of the result"]
    pub classindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_resultObj() {
    assert_eq!(
        ::std::mem::size_of::<resultObj>(),
        32usize,
        concat!("Size of: ", stringify!(resultObj))
    );
    assert_eq!(
        ::std::mem::align_of::<resultObj>(),
        8usize,
        concat!("Alignment of ", stringify!(resultObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultObj>())).shape as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resultObj),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultObj>())).shapeindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(resultObj),
            "::",
            stringify!(shapeindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultObj>())).tileindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(resultObj),
            "::",
            stringify!(tileindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultObj>())).resultindex as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(resultObj),
            "::",
            stringify!(resultindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultObj>())).classindex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(resultObj),
            "::",
            stringify!(classindex)
        )
    );
}
#[doc = "A cached result object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resultCacheObj {
    pub results: *mut resultObj,
    pub cachesize: ::std::os::raw::c_int,
    pub previousBounds: rectObj,
    #[doc = "< Length of result set"]
    pub numresults: ::std::os::raw::c_int,
    #[doc = "< Bounding box of query results"]
    pub bounds: rectObj,
}
#[test]
fn bindgen_test_layout_resultCacheObj() {
    assert_eq!(
        ::std::mem::size_of::<resultCacheObj>(),
        88usize,
        concat!("Size of: ", stringify!(resultCacheObj))
    );
    assert_eq!(
        ::std::mem::align_of::<resultCacheObj>(),
        8usize,
        concat!("Alignment of ", stringify!(resultCacheObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultCacheObj>())).results as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(resultCacheObj),
            "::",
            stringify!(results)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultCacheObj>())).cachesize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(resultCacheObj),
            "::",
            stringify!(cachesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultCacheObj>())).previousBounds as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(resultCacheObj),
            "::",
            stringify!(previousBounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultCacheObj>())).numresults as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(resultCacheObj),
            "::",
            stringify!(numresults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<resultCacheObj>())).bounds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(resultCacheObj),
            "::",
            stringify!(bounds)
        )
    );
}
#[doc = "A :class:`symbolSetObj` is an attribute of a :class:`mapObj` and is associated with instances of :class:`symbolObj`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symbolSetObj {
    pub refcount: ::std::os::raw::c_int,
    pub symbol: *mut *mut symbolObj,
    pub map: *mut mapObj,
    pub fontset: *mut fontSetObj,
    pub imagecache: *mut imageCacheObj,
    #[doc = "< Number of symbols in the set"]
    pub numsymbols: ::std::os::raw::c_int,
    #[doc = "< Maximum number of allowed symbols"]
    pub maxsymbols: ::std::os::raw::c_int,
    #[doc = "< Symbolset filename"]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = "< Symbols in the cache"]
    pub imagecachesize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_symbolSetObj() {
    assert_eq!(
        ::std::mem::size_of::<symbolSetObj>(),
        64usize,
        concat!("Size of: ", stringify!(symbolSetObj))
    );
    assert_eq!(
        ::std::mem::align_of::<symbolSetObj>(),
        8usize,
        concat!("Alignment of ", stringify!(symbolSetObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).symbol as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).fontset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(fontset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).imagecache as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(imagecache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).numsymbols as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(numsymbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).maxsymbols as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(maxsymbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).filename as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolSetObj>())).imagecachesize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolSetObj),
            "::",
            stringify!(imagecachesize)
        )
    );
}
#[doc = "The :ref:`REFERENCE <reference>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct referenceMapObj {
    #[doc = "< Reference to parent :class:`mapObj`"]
    pub map: *mut mapObj,
    #[doc = "< Spatial extent of reference in units of parent map - see :ref:`EXTENT <mapfile-reference-extent>`"]
    pub extent: rectObj,
    #[doc = "< Height of reference map in pixels - see :ref:`SIZE <mapfile-reference-size>`"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< Width of reference map in pixels - see :ref:`SIZE <mapfile-reference-size>`"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< Color of reference box - see :ref:`COLOR <mapfile-reference-color>`"]
    pub color: colorObj,
    #[doc = "< Outline color of reference box - see :ref:`OUTLINECOLOR <mapfile-reference-outlinecolor>`"]
    pub outlinecolor: colorObj,
    #[doc = "< Filename of reference map image - see :ref:`IMAGE <mapfile-reference-image>`"]
    pub image: *mut ::std::os::raw::c_char,
    #[doc = "< :data:`MS_ON` or :data:`MS_OFF` - see :ref:`STATUS <mapfile-reference-status>`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< Index of a symbol in the map symbol set to use for marker - see :ref:`MARKER <mapfile-reference-marker>`"]
    pub marker: ::std::os::raw::c_int,
    #[doc = "< Name of a symbol - see :ref:`MARKER <mapfile-reference-marker>`"]
    pub markername: *mut ::std::os::raw::c_char,
    #[doc = "< Size of marker - see :ref:`MARKERSIZE <mapfile-reference-markersize>`"]
    pub markersize: ::std::os::raw::c_int,
    #[doc = "< In pixels - see :ref:`MINBOXSIZE <mapfile-reference-minboxsize>`"]
    pub minboxsize: ::std::os::raw::c_int,
    #[doc = "< In pixels - see :ref:`MAXBOXSIZE <mapfile-reference-maxboxsize>`"]
    pub maxboxsize: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_referenceMapObj() {
    assert_eq!(
        ::std::mem::size_of::<referenceMapObj>(),
        120usize,
        concat!("Size of: ", stringify!(referenceMapObj))
    );
    assert_eq!(
        ::std::mem::align_of::<referenceMapObj>(),
        8usize,
        concat!("Alignment of ", stringify!(referenceMapObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).extent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).height as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).width as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).color as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).outlinecolor as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).image as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).status as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).marker as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).markername as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(markername)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).markersize as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(markersize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).minboxsize as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(minboxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<referenceMapObj>())).maxboxsize as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(referenceMapObj),
            "::",
            stringify!(maxboxsize)
        )
    );
}
#[doc = "The :ref:`SCALEBAR <scalebar>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scalebarObj {
    #[doc = "< Allows transparency for an embedded scalebar - see :ref:`TRANSPARENT <mapfile-scalebar-transparent>`"]
    pub transparent: ::std::os::raw::c_int,
    #[doc = "< Background color of scalebar - see :ref:`IMAGECOLOR <mapfile-scalebar-imagecolor>`"]
    pub imagecolor: colorObj,
    #[doc = "< Height in pixels - see :ref:`SIZE <mapfile-scalebar-size>`"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< Height in pixels - see :ref:`SIZE <mapfile-scalebar-size>`"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< 0 or 1 - see :ref:`STYLE <mapfile-scalebar-style>`"]
    pub style: ::std::os::raw::c_int,
    #[doc = "< Number of intervals - see :ref:`INTERVALS <mapfile-scalebar-intervals>`"]
    pub intervals: ::std::os::raw::c_int,
    #[doc = "< Scalebar label - see :ref:`LABEL <mapfile-scalebar-label>`"]
    pub label: labelObj,
    #[doc = "< Scalebar foreground color - see :ref:`COLOR <mapfile-scalebar-color>`"]
    pub color: colorObj,
    #[doc = "< Scalebar background color - see :ref:`BACKGROUNDCOLOR <mapfile-scalebar-backgroundcolor>`"]
    pub backgroundcolor: colorObj,
    #[doc = "< Foreground outline color - see :ref:`OUTLINECOLOR <mapfile-scalebar-outlinecolor>`"]
    pub outlinecolor: colorObj,
    #[doc = "< See :ref:`UNITS <mapfile-scalebar-units>`"]
    pub units: ::std::os::raw::c_int,
    #[doc = "< ON, OFF or EMBED - see :ref:`STATUS <mapfile-scalebar-status>` - :data:`MS_ON`, :data:`MS_OFF`, or :data:`MS_EMBED`."]
    pub status: ::std::os::raw::c_int,
    #[doc = "< For embeded scalebars - see :ref:`POSITION <mapfile-scalebar-position>` -"]
    #[doc = "< :data:`MS_UL`, :data:`MS_UC`, :data:`MS_UR`, :data:`MS_LL`, :data:`MS_LC`, or :data:`MS_LR`"]
    pub position: ::std::os::raw::c_int,
    #[doc = "< See :ref:`POSTLABELCACHE <mapfile-scalebar-postlabelcache>` - :data:`MS_TRUE` or :data:`MS_FALSE`"]
    pub postlabelcache: ::std::os::raw::c_int,
    #[doc = "< See :ref:`ALIGN <mapfile-scalebar-align>`"]
    pub align: ::std::os::raw::c_int,
    #[doc = "< See :ref:`OFFSET <mapfile-scalebar-offset>`"]
    pub offsetx: ::std::os::raw::c_int,
    #[doc = "< See :ref:`OFFSET <mapfile-scalebar-offset>`"]
    pub offsety: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_scalebarObj() {
    assert_eq!(
        ::std::mem::size_of::<scalebarObj>(),
        1360usize,
        concat!("Size of: ", stringify!(scalebarObj))
    );
    assert_eq!(
        ::std::mem::align_of::<scalebarObj>(),
        8usize,
        concat!("Alignment of ", stringify!(scalebarObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).transparent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(transparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).imagecolor as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(imagecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).style as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).intervals as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(intervals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).color as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).backgroundcolor as *const _ as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(backgroundcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).outlinecolor as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).units as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).status as *const _ as usize },
        1332usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).position as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).postlabelcache as *const _ as usize },
        1340usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(postlabelcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).align as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).offsetx as *const _ as usize },
        1348usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(offsetx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scalebarObj>())).offsety as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(scalebarObj),
            "::",
            stringify!(offsety)
        )
    );
}
#[doc = "The :ref:`LEGEND <legend>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct legendObj {
    #[doc = "< See :ref:`LABEL <mapfile-legend-label>`"]
    pub label: labelObj,
    #[doc = "< Instances of legendObj are always are always embedded inside the mapObj"]
    pub map: *mut mapObj,
    #[doc = "< Allows transparency for an embedded legend - see :ref:`TRANSPARENT <mapfile-legend-transparent>`"]
    pub transparent: ::std::os::raw::c_int,
    #[doc = "< Legend background color - see :ref:`IMAGECOLOR <mapfile-legend-imagecolor>`"]
    pub imagecolor: colorObj,
    #[doc = "< Width in pixels of legend keys - see :ref:`KEYSIZE <mapfile-legend-keysize>`"]
    pub keysizex: ::std::os::raw::c_int,
    #[doc = "< Height in pixels of legend keys - see :ref:`KEYSIZE <mapfile-legend-keysize>`"]
    pub keysizey: ::std::os::raw::c_int,
    #[doc = "< Horizontal padding around keys in pixels - see :ref:`KEYSPACING <mapfile-legend-keyspacing>`"]
    pub keyspacingx: ::std::os::raw::c_int,
    #[doc = "< Vertical padding around keys in pixels - see :ref:`KEYSPACING <mapfile-legend-keyspacing>`"]
    pub keyspacingy: ::std::os::raw::c_int,
    #[doc = "< Key outline color, -1 for no outline - see :ref:`OUTLINECOLOR <mapfile-legend-outlinecolor>`"]
    pub outlinecolor: colorObj,
    #[doc = "< :data:`MS_ON`, :data:`MS_OFF` or :data:`MS_EMBED`- see :ref:`STATUS <mapfile-legend-status>`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< Legend height"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< Legend width"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< Used for embedded legends, see :ref:`POSITION  <mapfile-legend-position>`"]
    pub position: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_TRUE`, :data:`MS_FALSE` - see :ref:`POSTLABELCACHE  <mapfile-legend-postlabelcache>`"]
    pub postlabelcache: ::std::os::raw::c_int,
    pub _template: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_legendObj() {
    assert_eq!(
        ::std::mem::size_of::<legendObj>(),
        1328usize,
        concat!("Size of: ", stringify!(legendObj))
    );
    assert_eq!(
        ::std::mem::align_of::<legendObj>(),
        8usize,
        concat!("Alignment of ", stringify!(legendObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).map as *const _ as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).transparent as *const _ as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(transparent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).imagecolor as *const _ as usize },
        1252usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(imagecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).keysizex as *const _ as usize },
        1268usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(keysizex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).keysizey as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(keysizey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).keyspacingx as *const _ as usize },
        1276usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(keyspacingx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).keyspacingy as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(keyspacingy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).outlinecolor as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).status as *const _ as usize },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).height as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).width as *const _ as usize },
        1308usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).position as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>())).postlabelcache as *const _ as usize },
        1316usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(postlabelcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<legendObj>()))._template as *const _ as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(legendObj),
            "::",
            stringify!(_template)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct graticuleObj {
    pub dwhichlatitude: f64,
    pub dwhichlongitude: f64,
    pub dstartlatitude: f64,
    pub dstartlongitude: f64,
    pub dendlatitude: f64,
    pub dendlongitude: f64,
    pub dincrementlatitude: f64,
    pub dincrementlongitude: f64,
    pub minarcs: f64,
    pub maxarcs: f64,
    pub minincrement: f64,
    pub maxincrement: f64,
    pub minsubdivides: f64,
    pub maxsubdivides: f64,
    pub bvertical: ::std::os::raw::c_int,
    pub blabelaxes: ::std::os::raw::c_int,
    pub ilabelstate: ::std::os::raw::c_int,
    pub ilabeltype: ::std::os::raw::c_int,
    pub extent: rectObj,
    pub pboundinglines: *mut lineObj,
    pub pboundingpoints: *mut pointObj,
    pub labelformat: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_graticuleObj() {
    assert_eq!(
        ::std::mem::size_of::<graticuleObj>(),
        184usize,
        concat!("Size of: ", stringify!(graticuleObj))
    );
    assert_eq!(
        ::std::mem::align_of::<graticuleObj>(),
        8usize,
        concat!("Alignment of ", stringify!(graticuleObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dwhichlatitude as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dwhichlatitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dwhichlongitude as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dwhichlongitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dstartlatitude as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dstartlatitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dstartlongitude as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dstartlongitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dendlatitude as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dendlatitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dendlongitude as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dendlongitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).dincrementlatitude as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dincrementlatitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleObj>())).dincrementlongitude as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(dincrementlongitude)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).minarcs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(minarcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).maxarcs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(maxarcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).minincrement as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(minincrement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).maxincrement as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(maxincrement)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).minsubdivides as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(minsubdivides)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).maxsubdivides as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(maxsubdivides)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).bvertical as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(bvertical)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).blabelaxes as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(blabelaxes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).ilabelstate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(ilabelstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).ilabeltype as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(ilabeltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).extent as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).pboundinglines as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(pboundinglines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).pboundingpoints as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(pboundingpoints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleObj>())).labelformat as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleObj),
            "::",
            stringify!(labelformat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct graticuleIntersectionObj {
    pub nTop: ::std::os::raw::c_int,
    pub pasTop: *mut pointObj,
    pub papszTopLabels: *mut *mut ::std::os::raw::c_char,
    pub nBottom: ::std::os::raw::c_int,
    pub pasBottom: *mut pointObj,
    pub papszBottomLabels: *mut *mut ::std::os::raw::c_char,
    pub nLeft: ::std::os::raw::c_int,
    pub pasLeft: *mut pointObj,
    pub papszLeftLabels: *mut *mut ::std::os::raw::c_char,
    pub nRight: ::std::os::raw::c_int,
    pub pasRight: *mut pointObj,
    pub papszRightLabels: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_graticuleIntersectionObj() {
    assert_eq!(
        ::std::mem::size_of::<graticuleIntersectionObj>(),
        96usize,
        concat!("Size of: ", stringify!(graticuleIntersectionObj))
    );
    assert_eq!(
        ::std::mem::align_of::<graticuleIntersectionObj>(),
        8usize,
        concat!("Alignment of ", stringify!(graticuleIntersectionObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleIntersectionObj>())).nTop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(nTop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleIntersectionObj>())).pasTop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(pasTop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).papszTopLabels as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(papszTopLabels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).nBottom as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(nBottom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).pasBottom as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(pasBottom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).papszBottomLabels as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(papszBottomLabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleIntersectionObj>())).nLeft as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(nLeft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).pasLeft as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(pasLeft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).papszLeftLabels as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(papszLeftLabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<graticuleIntersectionObj>())).nRight as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(nRight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).pasRight as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(pasRight)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<graticuleIntersectionObj>())).papszRightLabels as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(graticuleIntersectionObj),
            "::",
            stringify!(papszRightLabels)
        )
    );
}
pub type layerVTableObj = layerVTable;
#[doc = " An image object is a wrapper for images generated by MapServer."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imageObj {
    #[doc = "< image width in pixels"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< image height in pixels"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< image resolution in pixels per inch"]
    pub resolution: f64,
    #[doc = "< resolution factor"]
    pub resolutionfactor: f64,
    #[doc = "< if image is drawn by :func:`mapObj.draw` this is :ref:`IMAGEPATH <mapfile-web-imagepath>`"]
    pub imagepath: *mut ::std::os::raw::c_char,
    #[doc = "< if image is drawn by :func:`mapObj.draw` this is :ref:`IMAGEURL <mapfile-web-imageurl>`"]
    pub imageurl: *mut ::std::os::raw::c_char,
    #[doc = "< an :class:`outputFormatObj` representing the output format of the image"]
    pub format: *mut outputFormatObj,
    pub tilecache: *mut tileCacheObj,
    pub ntiles: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
    pub img: imageObj__bindgen_ty_1,
    pub img_mask: ms_bitarray,
    pub refpt: pointObj,
    pub map: *mut mapObj,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union imageObj__bindgen_ty_1 {
    pub plugin: *mut ::std::os::raw::c_void,
    pub imagemap: *mut ::std::os::raw::c_char,
    pub raw_16bit: *mut ::std::os::raw::c_short,
    pub raw_float: *mut f32,
    pub raw_byte: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_imageObj__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<imageObj__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(imageObj__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<imageObj__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(imageObj__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj__bindgen_ty_1>())).plugin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj__bindgen_ty_1),
            "::",
            stringify!(plugin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj__bindgen_ty_1>())).imagemap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj__bindgen_ty_1),
            "::",
            stringify!(imagemap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<imageObj__bindgen_ty_1>())).raw_16bit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj__bindgen_ty_1),
            "::",
            stringify!(raw_16bit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<imageObj__bindgen_ty_1>())).raw_float as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj__bindgen_ty_1),
            "::",
            stringify!(raw_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj__bindgen_ty_1>())).raw_byte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj__bindgen_ty_1),
            "::",
            stringify!(raw_byte)
        )
    );
}
#[test]
fn bindgen_test_layout_imageObj() {
    assert_eq!(
        ::std::mem::size_of::<imageObj>(),
        120usize,
        concat!("Size of: ", stringify!(imageObj))
    );
    assert_eq!(
        ::std::mem::align_of::<imageObj>(),
        8usize,
        concat!("Alignment of ", stringify!(imageObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).resolution as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).resolutionfactor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(resolutionfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).imagepath as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(imagepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).imageurl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(imageurl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).format as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).tilecache as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(tilecache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).ntiles as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(ntiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).size as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).img as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(img)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).img_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(img_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).refpt as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(refpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imageObj>())).map as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(imageObj),
            "::",
            stringify!(map)
        )
    );
}
#[doc = "An individual value within the :ref:`SCALETOKEN <mapfile-layer-scaletoken>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scaleTokenEntryObj {
    #[doc = "< The minimum scale for the replacement"]
    pub minscale: f64,
    #[doc = "< The maximum scale for the replacement"]
    pub maxscale: f64,
    #[doc = "< The token replacement value"]
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_scaleTokenEntryObj() {
    assert_eq!(
        ::std::mem::size_of::<scaleTokenEntryObj>(),
        24usize,
        concat!("Size of: ", stringify!(scaleTokenEntryObj))
    );
    assert_eq!(
        ::std::mem::align_of::<scaleTokenEntryObj>(),
        8usize,
        concat!("Alignment of ", stringify!(scaleTokenEntryObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenEntryObj>())).minscale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenEntryObj),
            "::",
            stringify!(minscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenEntryObj>())).maxscale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenEntryObj),
            "::",
            stringify!(maxscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenEntryObj>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenEntryObj),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "The :ref:`SCALETOKEN <mapfile-layer-scaletoken>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scaleTokenObj {
    #[doc = "< The name of the token to replace in the :ref:`DATA <mapfile-layer-data>` statement"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< The number of values within the scaletoken"]
    pub n_entries: ::std::os::raw::c_int,
    #[doc = "< A reference to the values"]
    pub tokens: *mut scaleTokenEntryObj,
}
#[test]
fn bindgen_test_layout_scaleTokenObj() {
    assert_eq!(
        ::std::mem::size_of::<scaleTokenObj>(),
        24usize,
        concat!("Size of: ", stringify!(scaleTokenObj))
    );
    assert_eq!(
        ::std::mem::align_of::<scaleTokenObj>(),
        8usize,
        concat!("Alignment of ", stringify!(scaleTokenObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenObj>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenObj>())).n_entries as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenObj),
            "::",
            stringify!(n_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scaleTokenObj>())).tokens as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(scaleTokenObj),
            "::",
            stringify!(tokens)
        )
    );
}
pub const sortOrderEnum_SORT_ASC: sortOrderEnum = 0;
pub const sortOrderEnum_SORT_DESC: sortOrderEnum = 1;
pub type sortOrderEnum = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sortByProperties {
    pub item: *mut ::std::os::raw::c_char,
    pub sortOrder: sortOrderEnum,
}
#[test]
fn bindgen_test_layout_sortByProperties() {
    assert_eq!(
        ::std::mem::size_of::<sortByProperties>(),
        16usize,
        concat!("Size of: ", stringify!(sortByProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<sortByProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(sortByProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sortByProperties>())).item as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sortByProperties),
            "::",
            stringify!(item)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sortByProperties>())).sortOrder as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sortByProperties),
            "::",
            stringify!(sortOrder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sortByClause {
    pub nProperties: ::std::os::raw::c_int,
    pub properties: *mut sortByProperties,
}
#[test]
fn bindgen_test_layout_sortByClause() {
    assert_eq!(
        ::std::mem::size_of::<sortByClause>(),
        16usize,
        concat!("Size of: ", stringify!(sortByClause))
    );
    assert_eq!(
        ::std::mem::align_of::<sortByClause>(),
        8usize,
        concat!("Alignment of ", stringify!(sortByClause))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sortByClause>())).nProperties as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sortByClause),
            "::",
            stringify!(nProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sortByClause>())).properties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sortByClause),
            "::",
            stringify!(properties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct originalScaleTokenStrings {
    pub data: *mut ::std::os::raw::c_char,
    pub tileitem: *mut ::std::os::raw::c_char,
    pub tileindex: *mut ::std::os::raw::c_char,
    pub filteritem: *mut ::std::os::raw::c_char,
    pub filter: *mut ::std::os::raw::c_char,
    pub processing: *mut *mut ::std::os::raw::c_char,
    pub processing_idx: *mut ::std::os::raw::c_int,
    pub n_processing: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_originalScaleTokenStrings() {
    assert_eq!(
        ::std::mem::size_of::<originalScaleTokenStrings>(),
        64usize,
        concat!("Size of: ", stringify!(originalScaleTokenStrings))
    );
    assert_eq!(
        ::std::mem::align_of::<originalScaleTokenStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(originalScaleTokenStrings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<originalScaleTokenStrings>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).tileitem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(tileitem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).tileindex as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(tileindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).filteritem as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(filteritem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).filter as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).processing as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(processing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).processing_idx as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(processing_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<originalScaleTokenStrings>())).n_processing as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(originalScaleTokenStrings),
            "::",
            stringify!(n_processing)
        )
    );
}
#[doc = "The :ref:`LAYER <layer>` object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layerObj {
    pub scaletokens: *mut scaleTokenObj,
    pub numscaletokens: ::std::os::raw::c_int,
    pub orig_st: *mut originalScaleTokenStrings,
    pub labelitemindex: ::std::os::raw::c_int,
    pub tileitemindex: ::std::os::raw::c_int,
    pub projection: projectionObj,
    pub project: ::std::os::raw::c_int,
    pub reprojectorLayerToMap: *mut reprojectionObj,
    pub reprojectorMapToLayer: *mut reprojectionObj,
    pub features: featureListNodeObjPtr,
    pub currentfeature: featureListNodeObjPtr,
    pub vtable: *mut layerVTableObj,
    pub layerinfo: *mut ::std::os::raw::c_void,
    pub wfslayerinfo: *mut ::std::os::raw::c_void,
    pub items: *mut *mut ::std::os::raw::c_char,
    pub iteminfo: *mut ::std::os::raw::c_void,
    pub filter: expressionObj,
    pub bandsitemindex: ::std::os::raw::c_int,
    pub filteritemindex: ::std::os::raw::c_int,
    pub styleitemindex: ::std::os::raw::c_int,
    pub processing: *mut *mut ::std::os::raw::c_char,
    pub joins: *mut joinObj,
    pub maskimage: *mut imageObj,
    pub grid: *mut graticuleObj,
    pub _geomtransform: expressionObj,
    pub sortBy: sortByClause,
    pub classitemindex: ::std::os::raw::c_int,
    pub resultcache: *mut resultCacheObj,
    pub scalefactor: f64,
    pub _class: *mut *mut classObj,
    #[doc = "< reference counting, RFC24"]
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< Number of layer classes"]
    pub numclasses: ::std::os::raw::c_int,
    #[doc = "< Used to track of the maximum number of classes - see RFC-17"]
    pub maxclasses: ::std::os::raw::c_int,
    #[doc = "< Index of layer within parent map's layers array"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< Reference to parent map"]
    pub map: *mut mapObj,
    #[doc = "< Number of layer feature attributes (items)"]
    pub numitems: ::std::os::raw::c_int,
    #[doc = "< See :ref:`METADATA <mapfile-layer-metadata>`"]
    pub metadata: hashTableObj,
    #[doc = "< See :ref:`VALIDATION <mapfile-layer-validation>`"]
    pub validation: hashTableObj,
    #[doc = "< Relates to RFC59"]
    pub bindvals: hashTableObj,
    #[doc = "< See :ref:`CONNECTIONOPTIONS <mapfile-layer-connectionoptions>`"]
    pub connectionoptions: hashTableObj,
    #[doc = "< See :ref:`CLUSTER <mapfile-layer-cluster>`"]
    pub cluster: clusterObj,
    #[doc = "< optional limiting extent for layer features - see :ref:`EXTENT <mapfile-layer-extent>`"]
    pub extent: rectObj,
    #[doc = "< Number of raster processing directives"]
    pub numprocessing: ::std::os::raw::c_int,
    #[doc = "< Number of layer joins"]
    pub numjoins: ::std::os::raw::c_int,
    #[doc = "< See :ref:`UTFDATA <mapfile-layer-utfdata>`"]
    pub utfdata: expressionObj,
    #[doc = "< See :ref:`COMPOSITE <mapfile-layer-composite>`"]
    pub compositer: *mut LayerCompositer,
    #[doc = "< the attribute used to classify layer data - see :ref:`CLASSITEM <mapfile-layer-classitem>`"]
    pub classitem: *mut ::std::os::raw::c_char,
    #[doc = "< filename to a template for result's header - see :ref:`HEADER <mapfile-layer-header>`"]
    pub header: *mut ::std::os::raw::c_char,
    #[doc = "< filename to a template for result's footer - see :ref:`FOOTER <mapfile-layer-footer>`"]
    pub footer: *mut ::std::os::raw::c_char,
    pub _template: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`NAME <mapfile-layer-name>` - should be unique"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Name of a group of layers - see :ref:`GROUP <mapfile-layer-group>`"]
    pub group: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`STATUS <mapfile-layer-status>`:data:`MS_ON`, :data:`MS_OFF` or :data:`MS_DEFAULT`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_FIRST_MATCHING_CLASS` - default and historic MapServer behavior, :data:`MS_ALL_MATCHING_CLASSES` - SLD behavior"]
    pub rendermode: MS_RENDER_MODE,
    #[doc = "< Layer data definition, values depend upon connectiontype - see :ref:`DATA <mapfile-layer-data>`"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = "< the layer type - see :ref:`TYPE <mapfile-layer-type>`"]
    pub type_: MS_LAYER_TYPE,
    #[doc = "< the layer connection type - see :ref:`CONNECTIONTYPE <mapfile-layer-connectiontype>`"]
    pub connectiontype: MS_CONNECTION_TYPE,
    #[doc = "< search buffer for point and line queries (in toleranceunits) - see :ref:`TOLERANCE <mapfile-layer-tolerance>`"]
    pub tolerance: f64,
    #[doc = "< See :ref:`TOLERANCEUNITS <mapfile-layer-toleranceunits>`"]
    pub toleranceunits: ::std::os::raw::c_int,
    #[doc = "< scale at which symbols are default size - see :ref:`SYMBOLSCALEDENOM <mapfile-layer-symbolscaledenom>`"]
    pub symbolscaledenom: f64,
    #[doc = "< Maximum scale at which layer will be drawn - see :ref:`MINSCALEDENOM <mapfile-layer-minscaledenom>`"]
    pub minscaledenom: f64,
    #[doc = "< Minimum scale at which layer will be drawn - see :ref:`MAXSCALEDENOM <mapfile-layer-maxscaledenom>`"]
    pub maxscaledenom: f64,
    #[doc = "< minimum feature size (in pixels) for shape"]
    pub minfeaturesize: ::std::os::raw::c_int,
    #[doc = "< See :ref:`LABELMINSCALEDENOM <mapfile-layer-labelminscaledenom>`"]
    pub labelminscaledenom: f64,
    #[doc = "< See :ref:`LABELMAXSCALEDENOM <mapfile-layer-labelmaxscaledenom>`"]
    pub labelmaxscaledenom: f64,
    #[doc = "< min map width (in map units) at which the layer should be drawn - see :ref:`MAXGEOWIDTH <mapfile-layer-maxgeowidth>`"]
    pub mingeowidth: f64,
    #[doc = "< max map width (in map units) at which the layer should be drawn - see :ref:`MAXGEOWIDTH <mapfile-layer-maxgeowidth>`"]
    pub maxgeowidth: f64,
    #[doc = "< applies to all classes - see :ref:`SIZEUNITS <mapfile-layer-sizeunits>`"]
    pub sizeunits: ::std::os::raw::c_int,
    #[doc = "< Maximum number of layer features that will be drawn - see :ref:`MAXFEATURES <mapfile-layer-maxfeatures>`"]
    pub maxfeatures: ::std::os::raw::c_int,
    #[doc = "< Feature start index - used for paging"]
    pub startindex: ::std::os::raw::c_int,
    #[doc = "< transparent pixel value for raster images - see :ref:`OFFSITE <mapfile-layer-offsite>`"]
    pub offsite: colorObj,
    #[doc = ":data:`MS_TRUE` (default) or :data:`MS_FALSE` whether or not layer data is to be transformed to"]
    #[doc = "image units - see :ref:`TRANSFORM <mapfile-layer-transform>`"]
    pub transform: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_ON` (default) or :data:`MS_OFF` - see :ref:`LABELCACHE <mapfile-layer-labelcache>`"]
    pub labelcache: ::std::os::raw::c_int,
    #[doc = "< :data:`MS_ON` or :data:`MS_OFF` (default) - see :ref:`POSTLABELCACHE <mapfile-layer-postlabelcache>`"]
    pub postlabelcache: ::std::os::raw::c_int,
    #[doc = "< attribute defining feature label text - see :ref:`LABELITEM <mapfile-layer-labelitem>`"]
    pub labelitem: *mut ::std::os::raw::c_char,
    #[doc = "< attribute defining tile paths - see :ref:`TILEITEM <mapfile-layer-tileitem>`"]
    pub tileitem: *mut ::std::os::raw::c_char,
    #[doc = "< layer index file for tiling support - see :ref:`TILEINDEX <mapfile-layer-tileindex>`"]
    pub tileindex: *mut ::std::os::raw::c_char,
    #[doc = "< name of the attribute that contains the SRS of an individual tile - see :ref:`TILESRS <mapfile-layer-tilesrs>`"]
    pub tilesrs: *mut ::std::os::raw::c_char,
    #[doc = "< units of the layer - see :ref:`UNITS <mapfile-layer-units>`"]
    pub units: ::std::os::raw::c_int,
    #[doc = "< layer connection or data source name - see :ref:`CONNECTION <mapfile-layer-connection>`"]
    pub connection: *mut ::std::os::raw::c_char,
    #[doc = "< Used to select the library to load by MapServer"]
    pub plugin_library: *mut ::std::os::raw::c_char,
    #[doc = "< this is needed for Mapfile writing"]
    pub plugin_library_original: *mut ::std::os::raw::c_char,
    #[doc = "The attribute from the index file used to select the source raster band(s) to be"]
    #[doc = "used - normally NULL for default bands processing"]
    pub bandsitem: *mut ::std::os::raw::c_char,
    #[doc = "< Attribute defining filter - see :ref:`FILTERITEM <mapfile-layer-filteritem>`"]
    pub filteritem: *mut ::std::os::raw::c_char,
    #[doc = "< item to be used for style lookup - can also be 'AUTO' - see :ref:`STYLEITEM <mapfile-layer-styleitem>`"]
    pub styleitem: *mut ::std::os::raw::c_char,
    #[doc = "< Context expressions, simple enough to not use expressionObj - see :ref:`REQUIRES <mapfile-layer-requires>`"]
    pub requires: *mut ::std::os::raw::c_char,
    #[doc = "< Simple logical expression - see :ref:`LABELREQUIRES <mapfile-layer-labelrequires>`"]
    pub labelrequires: *mut ::std::os::raw::c_char,
    #[doc = "< Enable debugging of layer-  :data:`MS_ON` or :data:`MS_OFF` (default) - see :ref:`DEBUG <mapfile-layer-debug>`"]
    pub debug: ::std::os::raw::c_int,
    #[doc = "< See :ref:`CLASSGROUP <mapfile-layer-classgroup>`"]
    pub classgroup: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`MASK <mapfile-layer-mask>`"]
    pub mask: *mut ::std::os::raw::c_char,
    #[doc = "< For iconving shape attributes, ignored if NULL or \"utf-8\" - see :ref:`ENCODING <mapfile-layer-encoding>`"]
    pub encoding: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`UTFITEM <mapfile-layer-utfitem>`"]
    pub utfitem: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`CLASSITEM <mapfile-layer-classitem>`"]
    pub utfitemindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_layerObj() {
    assert_eq!(
        ::std::mem::size_of::<layerObj>(),
        1152usize,
        concat!("Size of: ", stringify!(layerObj))
    );
    assert_eq!(
        ::std::mem::align_of::<layerObj>(),
        8usize,
        concat!("Alignment of ", stringify!(layerObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).scaletokens as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(scaletokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).numscaletokens as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(numscaletokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).orig_st as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(orig_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelitemindex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).tileitemindex as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(tileitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).projection as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).project as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(project)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).reprojectorLayerToMap as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(reprojectorLayerToMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).reprojectorMapToLayer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(reprojectorMapToLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).features as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).currentfeature as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(currentfeature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).vtable as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).layerinfo as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(layerinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).wfslayerinfo as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(wfslayerinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).items as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).iteminfo as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(iteminfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).filter as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).bandsitemindex as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(bandsitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).filteritemindex as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(filteritemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).styleitemindex as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(styleitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).processing as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(processing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).joins as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(joins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).maskimage as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(maskimage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).grid as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(grid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>()))._geomtransform as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(_geomtransform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).sortBy as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(sortBy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).classitemindex as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(classitemindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).resultcache as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(resultcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).scalefactor as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(scalefactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>()))._class as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).refcount as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).numclasses as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(numclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).maxclasses as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(maxclasses)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).index as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).map as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).numitems as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(numitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).metadata as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).validation as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(validation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).bindvals as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(bindvals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).connectionoptions as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(connectionoptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).cluster as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).extent as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).numprocessing as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(numprocessing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).numjoins as *const _ as usize },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(numjoins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).utfdata as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(utfdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).compositer as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(compositer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).classitem as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(classitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).header as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).footer as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(footer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>()))._template as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(_template)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).name as *const _ as usize },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).group as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).status as *const _ as usize },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).rendermode as *const _ as usize },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(rendermode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).data as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).type_ as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).connectiontype as *const _ as usize },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(connectiontype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).tolerance as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).toleranceunits as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(toleranceunits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).symbolscaledenom as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(symbolscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).minscaledenom as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(minscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).maxscaledenom as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(maxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).minfeaturesize as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(minfeaturesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelminscaledenom as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelminscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelmaxscaledenom as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelmaxscaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).mingeowidth as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(mingeowidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).maxgeowidth as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(maxgeowidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).sizeunits as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(sizeunits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).maxfeatures as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(maxfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).startindex as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(startindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).offsite as *const _ as usize },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(offsite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).transform as *const _ as usize },
        988usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelcache as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).postlabelcache as *const _ as usize },
        996usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(postlabelcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelitem as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).tileitem as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(tileitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).tileindex as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(tileindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).tilesrs as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(tilesrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).units as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).connection as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).plugin_library as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(plugin_library)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerObj>())).plugin_library_original as *const _ as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(plugin_library_original)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).bandsitem as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(bandsitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).filteritem as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(filteritem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).styleitem as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(styleitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).requires as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(requires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).labelrequires as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(labelrequires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).debug as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).classgroup as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(classgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).mask as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).encoding as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).utfitem as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(utfitem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerObj>())).utfitemindex as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(layerObj),
            "::",
            stringify!(utfitemindex)
        )
    );
}
extern "C" {
    pub fn msFontCacheSetup();
}
extern "C" {
    pub fn msFontCacheCleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct glyphObj {
    pub glyph: *mut glyph_element,
    pub face: *mut face_element,
    pub pnt: pointObj,
    pub rot: f64,
}
#[test]
fn bindgen_test_layout_glyphObj() {
    assert_eq!(
        ::std::mem::size_of::<glyphObj>(),
        56usize,
        concat!("Size of: ", stringify!(glyphObj))
    );
    assert_eq!(
        ::std::mem::align_of::<glyphObj>(),
        8usize,
        concat!("Alignment of ", stringify!(glyphObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphObj>())).glyph as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphObj),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphObj>())).face as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphObj),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphObj>())).pnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphObj),
            "::",
            stringify!(pnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<glyphObj>())).rot as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(glyphObj),
            "::",
            stringify!(rot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textPathObj {
    pub numglyphs: ::std::os::raw::c_int,
    pub numlines: ::std::os::raw::c_int,
    pub line_height: ::std::os::raw::c_int,
    pub glyph_size: ::std::os::raw::c_int,
    pub absolute: ::std::os::raw::c_int,
    pub glyphs: *mut glyphObj,
    pub bounds: label_bounds,
}
#[test]
fn bindgen_test_layout_textPathObj() {
    assert_eq!(
        ::std::mem::size_of::<textPathObj>(),
        72usize,
        concat!("Size of: ", stringify!(textPathObj))
    );
    assert_eq!(
        ::std::mem::align_of::<textPathObj>(),
        8usize,
        concat!("Alignment of ", stringify!(textPathObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).numglyphs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(numglyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).numlines as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(numlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).line_height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(line_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).glyph_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(glyph_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).absolute as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(absolute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).glyphs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(glyphs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textPathObj>())).bounds as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(textPathObj),
            "::",
            stringify!(bounds)
        )
    );
}
pub const label_cache_mode_duplicate_never: label_cache_mode = 0;
pub const label_cache_mode_duplicate_always: label_cache_mode = 1;
pub const label_cache_mode_duplicate_if_needed: label_cache_mode = 2;
pub type label_cache_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn msComputeTextPath(map: *mut mapObj, ts: *mut textSymbolObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyTextPath(dst: *mut textPathObj, src: *mut textPathObj);
}
extern "C" {
    pub fn msCopyTextSymbol(dst: *mut textSymbolObj, src: *mut textSymbolObj);
}
extern "C" {
    pub fn msPopulateTextSymbolForLabelAndString(
        ts: *mut textSymbolObj,
        l: *mut labelObj,
        string: *mut ::std::os::raw::c_char,
        scalefactor: f64,
        resolutionfactor: f64,
        cache: label_cache_mode,
    );
}
#[doc = "The :ref:`MAP <map>` object"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mapObj {
    pub layers: *mut *mut layerObj,
    pub gt: geotransformObj,
    pub saved_extent: rectObj,
    pub palette: paletteObj,
    pub outputformatlist: *mut *mut outputFormatObj,
    pub projection: projectionObj,
    pub latlon: projectionObj,
    pub encryption_key_loaded: ::std::os::raw::c_int,
    pub encryption_key: [::std::os::raw::c_uchar; 16usize],
    pub query: queryObj,
    pub projContext: *mut projectionContext,
    #[doc = "< Used for reference counting see RFC24"]
    pub refcount: ::std::os::raw::c_int,
    #[doc = "< Number of layers in mapfile"]
    pub numlayers: ::std::os::raw::c_int,
    #[doc = "< Allocated size of layers[] array"]
    pub maxlayers: ::std::os::raw::c_int,
    #[doc = "A hash table of configuration options from CONFIG keywords"]
    #[doc = "in the map - see :ref:`CONFIG <mapfile-map-config>`"]
    pub configoptions: hashTableObj,
    #[doc = "< See :ref:`SYMBOLSET <mapfile-map-symbolset>`"]
    pub symbolset: symbolSetObj,
    #[doc = "< See :ref:`FONTSET <mapfile-map-fontset>`"]
    pub fontset: fontSetObj,
    #[doc = "< We need this here so multiple feature processors can access it"]
    pub labelcache: labelCacheObj,
    #[doc = "< Number of output formats available in the map"]
    pub numoutputformats: ::std::os::raw::c_int,
    #[doc = "< See :ref:`OUTPUTFORMAT <mapfile-map-outputformat>`"]
    pub outputformat: *mut outputFormatObj,
    #[doc = "< Name of current outputformat"]
    pub imagetype: *mut ::std::os::raw::c_char,
    #[doc = "< See :ref:`SCALEBAR <mapfile-map-scalebar>`"]
    pub reference: referenceMapObj,
    #[doc = "< See :ref:`SCALEBAR <mapfile-map-scalebar>`"]
    pub scalebar: scalebarObj,
    #[doc = "< See :ref:`LEGEND <mapfile-map-legend>`"]
    pub legend: legendObj,
    #[doc = "< See :ref:`QUERYMAP <mapfile-map-querymap>`"]
    pub querymap: queryMapObj,
    #[doc = "< See :ref:`WEB <mapfile-map-web>`"]
    pub web: webObj,
    pub config: *const configObj,
    #[doc = "< TODO - Deprecated use VALIDATION ... END block instead"]
    pub datapattern: *mut ::std::os::raw::c_char,
    #[doc = "< TODO - Deprecated use VALIDATION ... END block instead"]
    pub templatepattern: *mut ::std::os::raw::c_char,
    #[doc = "< Small identifier for naming etc - see :ref:`NAME <mapfile-map-name>`"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< Is map creation on or off - see :ref:`STATUS <mapfile-map-status>`"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< See :ref:`SIZE <mapfile-map-size>`"]
    pub height: ::std::os::raw::c_int,
    #[doc = "< See :ref:`SIZE <mapfile-map-size>`"]
    pub width: ::std::os::raw::c_int,
    #[doc = "< See :ref:`MAXSIZE  <mapfile-map-maxsize>`"]
    pub maxsize: ::std::os::raw::c_int,
    #[doc = "< Map extent array - see :ref:`EXTENT <mapfile-map-extent>`"]
    pub extent: rectObj,
    #[doc = "< Pixel size in map units"]
    pub cellsize: f64,
    #[doc = "< Units of the projection - see :ref:`UNITS <mapfile-map-units>`"]
    pub units: MS_UNITS,
    #[doc = "< The nominal map scale, a value of 25000 means 1:25000 scale - see :ref:`SCALEDENOM  <mapfile-map-scaledenom>`"]
    pub scaledenom: f64,
    #[doc = "< See :ref:`RESOLUTION <mapfile-map-resolution>`"]
    pub resolution: f64,
    #[doc = "< Default resolution - used to calculate the scalefactor, see :ref:`DEFRESOLUTION <mapfile-map-defresolution>`"]
    pub defresolution: f64,
    #[doc = "< Where are the shape files located - see :ref:`SHAPEPATH <mapfile-map-shapepath>`"]
    pub shapepath: *mut ::std::os::raw::c_char,
    #[doc = "< Path of the mapfile, all paths are relative to this path"]
    pub mappath: *mut ::std::os::raw::c_char,
    #[doc = "URL of SLD document as specified with \"&SLD=...\" WMS parameter d- currently this reference is"]
    #[doc = "used only in mapogcsld.c and has a NULL value outside that context"]
    pub sldurl: *mut ::std::os::raw::c_char,
    #[doc = "< Holds the initial image color value - see :ref:`IMAGECOLOR <mapfile-map-imagecolor>`"]
    pub imagecolor: colorObj,
    #[doc = "< Used to modify the order in which the layers are drawn - TODO should be immutable?"]
    pub layerorder: *mut ::std::os::raw::c_int,
    #[doc = "< See :ref:`DEBUG <mapfile-map-debug>`"]
    pub debug: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mapObj() {
    assert_eq!(
        ::std::mem::size_of::<mapObj>(),
        9512usize,
        concat!("Size of: ", stringify!(mapObj))
    );
    assert_eq!(
        ::std::mem::align_of::<mapObj>(),
        8usize,
        concat!("Alignment of ", stringify!(mapObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).layers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).gt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(gt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).saved_extent as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(saved_extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).palette as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).outputformatlist as *const _ as usize },
        5256usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(outputformatlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).projection as *const _ as usize },
        5264usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).latlon as *const _ as usize },
        5416usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(latlon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).encryption_key_loaded as *const _ as usize },
        5568usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(encryption_key_loaded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).encryption_key as *const _ as usize },
        5572usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(encryption_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).query as *const _ as usize },
        5592usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).projContext as *const _ as usize },
        5808usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(projContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).refcount as *const _ as usize },
        5816usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).numlayers as *const _ as usize },
        5820usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(numlayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).maxlayers as *const _ as usize },
        5824usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(maxlayers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).configoptions as *const _ as usize },
        5832usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(configoptions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).symbolset as *const _ as usize },
        5848usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(symbolset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).fontset as *const _ as usize },
        5912usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(fontset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).labelcache as *const _ as usize },
        5952usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(labelcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).numoutputformats as *const _ as usize },
        6304usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(numoutputformats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).outputformat as *const _ as usize },
        6312usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(outputformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).imagetype as *const _ as usize },
        6320usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(imagetype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).reference as *const _ as usize },
        6328usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).scalebar as *const _ as usize },
        6448usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(scalebar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).legend as *const _ as usize },
        7808usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(legend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).querymap as *const _ as usize },
        9136usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(querymap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).web as *const _ as usize },
        9176usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(web)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).config as *const _ as usize },
        9336usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).datapattern as *const _ as usize },
        9344usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(datapattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).templatepattern as *const _ as usize },
        9352usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(templatepattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).name as *const _ as usize },
        9360usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).status as *const _ as usize },
        9368usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).height as *const _ as usize },
        9372usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).width as *const _ as usize },
        9376usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).maxsize as *const _ as usize },
        9380usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).extent as *const _ as usize },
        9384usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).cellsize as *const _ as usize },
        9416usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(cellsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).units as *const _ as usize },
        9424usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).scaledenom as *const _ as usize },
        9432usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(scaledenom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).resolution as *const _ as usize },
        9440usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).defresolution as *const _ as usize },
        9448usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(defresolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).shapepath as *const _ as usize },
        9456usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(shapepath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).mappath as *const _ as usize },
        9464usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(mappath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).sldurl as *const _ as usize },
        9472usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(sldurl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).imagecolor as *const _ as usize },
        9480usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(imagecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).layerorder as *const _ as usize },
        9496usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(layerorder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mapObj>())).debug as *const _ as usize },
        9504usize,
        concat!(
            "Offset of field: ",
            stringify!(mapObj),
            "::",
            stringify!(debug)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layerVTable {
    pub LayerTranslateFilter: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            filter: *mut expressionObj,
            filteritem: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerSupportsCommonFilters:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerInitItemInfo:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerFreeItemInfo: ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj)>,
    pub LayerOpen:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerIsOpen:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerWhichShapes: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            rect: rectObj,
            isQuery: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerNextShape: ::std::option::Option<
        unsafe extern "C" fn(layer: *mut layerObj, shape: *mut shapeObj) -> ::std::os::raw::c_int,
    >,
    pub LayerGetShape: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            shape: *mut shapeObj,
            record: *mut resultObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerGetShapeCount: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            rect: rectObj,
            rectProjection: *mut projectionObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerClose:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerGetItems:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerGetExtent: ::std::option::Option<
        unsafe extern "C" fn(layer: *mut layerObj, extent: *mut rectObj) -> ::std::os::raw::c_int,
    >,
    pub LayerGetAutoStyle: ::std::option::Option<
        unsafe extern "C" fn(
            map: *mut mapObj,
            layer: *mut layerObj,
            c: *mut classObj,
            shape: *mut shapeObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerCloseConnection:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerSetTimeFilter: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            timestring: *const ::std::os::raw::c_char,
            timefield: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerApplyFilterToLayer: ::std::option::Option<
        unsafe extern "C" fn(
            psNode: *mut FilterEncodingNode,
            map: *mut mapObj,
            iLayerIndex: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerCreateItems: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            nt: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerGetNumFeatures:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
    pub LayerGetAutoProjection: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            projection: *mut projectionObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub LayerEscapeSQLParam: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            pszString: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub LayerEscapePropertyName: ::std::option::Option<
        unsafe extern "C" fn(
            layer: *mut layerObj,
            pszString: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub LayerEnablePaging: ::std::option::Option<
        unsafe extern "C" fn(layer: *mut layerObj, value: ::std::os::raw::c_int),
    >,
    pub LayerGetPaging:
        ::std::option::Option<unsafe extern "C" fn(layer: *mut layerObj) -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_layerVTable() {
    assert_eq!(
        ::std::mem::size_of::<layerVTable>(),
        192usize,
        concat!("Size of: ", stringify!(layerVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<layerVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(layerVTable))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerTranslateFilter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerTranslateFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerSupportsCommonFilters as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerSupportsCommonFilters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerInitItemInfo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerInitItemInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerFreeItemInfo as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerFreeItemInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerOpen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerIsOpen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerIsOpen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerWhichShapes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerWhichShapes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerNextShape as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerNextShape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetShape as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetShape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetShapeCount as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetShapeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerClose as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerClose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetItems as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetExtent as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetExtent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetAutoStyle as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetAutoStyle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerCloseConnection as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerCloseConnection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerSetTimeFilter as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerSetTimeFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerApplyFilterToLayer as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerApplyFilterToLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerCreateItems as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerCreateItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetNumFeatures as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetNumFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerGetAutoProjection as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetAutoProjection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerEscapeSQLParam as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerEscapeSQLParam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<layerVTable>())).LayerEscapePropertyName as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerEscapePropertyName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerEnablePaging as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerEnablePaging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layerVTable>())).LayerGetPaging as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(layerVTable),
            "::",
            stringify!(LayerGetPaging)
        )
    );
}
extern "C" {
    #[doc = "Saves a map image to a file"]
    pub fn msSaveImage(
        map: *mut mapObj,
        img: *mut imageObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Generic function to free a imageObj"]
    pub fn msFreeImage(img: *mut imageObj);
}
extern "C" {
    #[doc = "Sets up threads and font cache - called when MapScript is initialised"]
    pub fn msSetup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Attempts to recover all dynamically allocated resources allocated by MapServer code and"]
    #[doc = "dependent libraries. It is used primarily for final clean-up in scripts that need to do"]
    #[doc = "memory leak testing to get rid of \"noise\" one-time allocations."]
    #[doc = "It should not normally be used by production code."]
    pub fn msCleanup();
}
extern "C" {
    #[doc = "Sets up string-based mapfile loading and calls loadMapInternal to do the work"]
    pub fn msLoadMapFromString(
        buffer: *mut ::std::os::raw::c_char,
        new_mappath: *mut ::std::os::raw::c_char,
        config: *const configObj,
    ) -> *mut mapObj;
}
extern "C" {
    pub fn msBuildPluginLibraryPath(
        dest: *mut *mut ::std::os::raw::c_char,
        lib_str: *const ::std::os::raw::c_char,
        map: *mut mapObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGrowMapLayers(map: *mut mapObj) -> *mut layerObj;
}
extern "C" {
    pub fn msGrowLayerClasses(layer: *mut layerObj) -> *mut classObj;
}
extern "C" {
    pub fn msGrowLayerScaletokens(layer: *mut layerObj) -> *mut scaleTokenObj;
}
extern "C" {
    pub fn msGrowClassStyles(_class: *mut classObj) -> *mut styleObj;
}
extern "C" {
    pub fn msGrowClassLabels(_class: *mut classObj) -> *mut labelObj;
}
extern "C" {
    pub fn msGrowLabelStyles(label: *mut labelObj) -> *mut styleObj;
}
extern "C" {
    pub fn msGrowLeaderStyles(leader: *mut labelLeaderObj) -> *mut styleObj;
}
extern "C" {
    pub fn msMaybeAllocateClassStyle(
        c: *mut classObj,
        idx: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadExpressionString(
        exp: *mut expressionObj,
        value: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetExpressionString(exp: *mut expressionObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msInitExpression(exp: *mut expressionObj);
}
extern "C" {
    pub fn msFreeExpressionTokens(exp: *mut expressionObj);
}
extern "C" {
    pub fn msFreeExpression(exp: *mut expressionObj);
}
extern "C" {
    pub fn msApplySubstitutions(
        map: *mut mapObj,
        names: *mut *mut ::std::os::raw::c_char,
        values: *mut *mut ::std::os::raw::c_char,
        npairs: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msApplyDefaultSubstitutions(map: *mut mapObj);
}
extern "C" {
    pub fn msFreeMap(map: *mut mapObj);
}
extern "C" {
    pub fn msNewMapObj() -> *mut mapObj;
}
extern "C" {
    pub fn msGetConfigOption(
        map: *mut mapObj,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msSetConfigOption(
        map: *mut mapObj,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msTestConfigOption(
        map: *mut mapObj,
        key: *const ::std::os::raw::c_char,
        default_result: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msApplyMapConfigOptions(map: *mut mapObj);
}
extern "C" {
    pub fn msMapComputeGeotransform(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapComputeGeotransformEx(
        map: *mut mapObj,
        resolutionX: f64,
        resolutionY: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapPixelToGeoref(map: *mut mapObj, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn msMapGeorefToPixel(map: *mut mapObj, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn msMapSetExtent(
        map: *mut mapObj,
        minx: f64,
        miny: f64,
        maxx: f64,
        maxy: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapOffsetExtent(map: *mut mapObj, x: f64, y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapScaleExtent(
        map: *mut mapObj,
        zoomfactor: f64,
        minscaledenom: f64,
        maxscaledenom: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapSetCenter(map: *mut mapObj, center: *mut pointObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapSetRotation(map: *mut mapObj, rotation_angle: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapSetSize(
        map: *mut mapObj,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapSetFakedExtent(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapRestoreRealExtent(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapLoadOWSParameters(
        map: *mut mapObj,
        request: *mut cgiRequestObj,
        wmtver_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMapIgnoreMissingData(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msValidateParameter(
        value: *const ::std::os::raw::c_char,
        pattern1: *const ::std::os::raw::c_char,
        pattern2: *const ::std::os::raw::c_char,
        pattern3: *const ::std::os::raw::c_char,
        pattern4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetLayerIndex(
        map: *mut mapObj,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetSymbolIndex(
        set: *mut symbolSetObj,
        name: *mut ::std::os::raw::c_char,
        try_addimage_if_notfound: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadMap(
        filename: *const ::std::os::raw::c_char,
        new_mappath: *const ::std::os::raw::c_char,
        config: *const configObj,
    ) -> *mut mapObj;
}
extern "C" {
    pub fn msTransformXmlMapfile(
        stylesheet: *const ::std::os::raw::c_char,
        xmlMapfile: *const ::std::os::raw::c_char,
        tmpfile: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSaveMap(
        map: *mut mapObj,
        filename: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSaveConfig(
        map: *mut configObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeCharArray(
        array: *mut *mut ::std::os::raw::c_char,
        num_items: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msUpdateScalebarFromString(
        scalebar: *mut scalebarObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateQueryMapFromString(
        querymap: *mut queryMapObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateLabelFromString(
        label: *mut labelObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateClusterFromString(
        cluster: *mut clusterObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateReferenceMapFromString(
        ref_: *mut referenceMapObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateLegendFromString(
        legend: *mut legendObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateWebFromString(
        web: *mut webObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateStyleFromString(
        style: *mut styleObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateClassFromString(
        _class: *mut classObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUpdateLayerFromString(
        layer: *mut layerObj,
        string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msWriteLayerToString(layer: *mut layerObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteMapToString(map: *mut mapObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteClassToString(_class: *mut classObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteStyleToString(style: *mut styleObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteLabelToString(label: *mut labelObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteWebToString(web: *mut webObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteScalebarToString(scalebar: *mut scalebarObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteQueryMapToString(querymap: *mut queryMapObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteReferenceMapToString(ref_: *mut referenceMapObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteLegendToString(legend: *mut legendObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msWriteClusterToString(cluster: *mut clusterObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msIsValidRegex(e: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEvalRegex(
        e: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCaseEvalRegex(
        e: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msTokenizeMap(
        filename: *mut ::std::os::raw::c_char,
        numtokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msInitLabelCache(cache: *mut labelCacheObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeLabelCache(cache: *mut labelCacheObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCheckConnection(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCloseConnections(map: *mut mapObj);
}
extern "C" {
    pub fn msOGRInitialize();
}
extern "C" {
    pub fn msOGRCleanup();
}
extern "C" {
    pub fn msGDALCleanup();
}
extern "C" {
    pub fn msGDALInitialize();
}
extern "C" {
    pub fn msDrawScalebar(map: *mut mapObj) -> *mut imageObj;
}
extern "C" {
    pub fn msCalculateScale(
        extent: rectObj,
        units: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        resolution: f64,
        scaledenom: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInchesPerUnit(units: ::std::os::raw::c_int, center_lat: f64) -> f64;
}
extern "C" {
    pub fn msEmbedScalebar(map: *mut mapObj, img: *mut imageObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPointInRect(p: *const pointObj, rect: *const rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRectOverlap(a: *const rectObj, b: *const rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRectContained(a: *const rectObj, b: *const rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRectIntersect(a: *mut rectObj, b: *const rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRectToFormattedString(
        rect: *mut rectObj,
        format: *mut ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msPointToFormattedString(
        point: *mut pointObj,
        format: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        buffer_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msIsDegenerateShape(shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMergeRect(a: *mut rectObj, b: *mut rectObj);
}
extern "C" {
    pub fn msDistancePointToPoint(a: *mut pointObj, b: *mut pointObj) -> f64;
}
extern "C" {
    pub fn msSquareDistancePointToPoint(a: *mut pointObj, b: *mut pointObj) -> f64;
}
extern "C" {
    pub fn msDistancePointToSegment(p: *mut pointObj, a: *mut pointObj, b: *mut pointObj) -> f64;
}
extern "C" {
    pub fn msSquareDistancePointToSegment(
        p: *mut pointObj,
        a: *mut pointObj,
        b: *mut pointObj,
    ) -> f64;
}
extern "C" {
    pub fn msDistancePointToShape(p: *mut pointObj, shape: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msSquareDistancePointToShape(p: *mut pointObj, shape: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msDistanceSegmentToSegment(
        pa: *mut pointObj,
        pb: *mut pointObj,
        pc: *mut pointObj,
        pd: *mut pointObj,
    ) -> f64;
}
extern "C" {
    pub fn msDistanceShapeToShape(shape1: *mut shapeObj, shape2: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msIntersectSegments(
        a: *const pointObj,
        b: *const pointObj,
        c: *const pointObj,
        d: *const pointObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPointInPolygon(p: *mut pointObj, c: *mut lineObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIntersectMultipointPolygon(
        multipoint: *mut shapeObj,
        polygon: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIntersectPointPolygon(
        p: *mut pointObj,
        polygon: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIntersectPolylinePolygon(
        line: *mut shapeObj,
        poly: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIntersectPolygons(p1: *mut shapeObj, p2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIntersectPolylines(
        line1: *mut shapeObj,
        line2: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitQuery(query: *mut queryObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeQuery(query: *mut queryObj);
}
extern "C" {
    pub fn msSaveQuery(
        map: *mut mapObj,
        filename: *mut ::std::os::raw::c_char,
        results: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadQuery(
        map: *mut mapObj,
        filename: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msExecuteQuery(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByIndex(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByAttributes(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByPoint(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByRect(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByFeatures(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByShape(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryByFilter(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetQueryResultBounds(map: *mut mapObj, bounds: *mut rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIsLayerQueryable(lp: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msQueryFree(map: *mut mapObj, qlayer: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msRasterQueryByShape(
        map: *mut mapObj,
        layer: *mut layerObj,
        selectshape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRasterQueryByRect(
        map: *mut mapObj,
        layer: *mut layerObj,
        queryRect: rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRasterQueryByPoint(
        map: *mut mapObj,
        layer: *mut layerObj,
        mode: ::std::os::raw::c_int,
        p: pointObj,
        buffer: f64,
        maxresults: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringTrim(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStringTrimBlanks(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStringTrimLeft(string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringChop(string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringTrimEOL(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msReplaceSubstring(
        str_: *mut ::std::os::raw::c_char,
        old: *const ::std::os::raw::c_char,
        sznew: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msReplaceChar(
        str_: *mut ::std::os::raw::c_char,
        old: ::std::os::raw::c_char,
        sznew: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msCaseReplaceSubstring(
        str_: *mut ::std::os::raw::c_char,
        old: *const ::std::os::raw::c_char,
        sznew: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStripPath(fn_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msGetPath(fn_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msBuildPath(
        pszReturnPath: *mut ::std::os::raw::c_char,
        abs_path: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msBuildPath3(
        pszReturnPath: *mut ::std::os::raw::c_char,
        abs_path: *const ::std::os::raw::c_char,
        path1: *const ::std::os::raw::c_char,
        path2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTryBuildPath(
        szReturnPath: *mut ::std::os::raw::c_char,
        abs_path: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTryBuildPath3(
        szReturnPath: *mut ::std::os::raw::c_char,
        abs_path: *const ::std::os::raw::c_char,
        path1: *const ::std::os::raw::c_char,
        path2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringSplit(
        string: *const ::std::os::raw::c_char,
        cd: ::std::os::raw::c_char,
        num_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringSplitComplex(
        pszString: *const ::std::os::raw::c_char,
        pszDelimiters: *const ::std::os::raw::c_char,
        num_tokens: *mut ::std::os::raw::c_int,
        nFlags: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringArrayContains(
        array: *mut *mut ::std::os::raw::c_char,
        element: *const ::std::os::raw::c_char,
        numElements: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringTokenize(
        pszLine: *const ::std::os::raw::c_char,
        pszDelim: *const ::std::os::raw::c_char,
        num_tokens: *mut ::std::os::raw::c_int,
        preserve_quote: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msCountChars(
        str_: *mut ::std::os::raw::c_char,
        ch: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLongToString(value: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDoubleToString(
        value: f64,
        force_f: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msIntToString(value: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringToUpper(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStringToLower(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStringInitCap(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStringFirstCap(string: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msEncodeChar(arg1: ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEncodeUrlExcept(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msEncodeUrl(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msEscapeJSonString(
        pszJSonString: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msEncodeHTMLEntities(
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msDecodeHTMLEntities(string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn msIsXMLTagValid(string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringConcatenate(
        pszDest: *mut ::std::os::raw::c_char,
        pszSrc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msJoinStrings(
        array: *mut *mut ::std::os::raw::c_char,
        arrayLength: ::std::os::raw::c_int,
        delimeter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msHashString(pszStr: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msCommifyString(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msHexToInt(hex: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetEncodedString(
        string: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msConvertWideStringToUTF8(
        string: *const u32,
        encoding: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msConvertWideStringFromUTF8(
        string: *const ::std::os::raw::c_char,
        encoding: *const ::std::os::raw::c_char,
    ) -> *mut u32;
}
extern "C" {
    pub fn msGetNextGlyph(
        in_ptr: *mut *const ::std::os::raw::c_char,
        out_string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetNumGlyphs(in_ptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetUnicodeEntity(
        inptr: *const ::std::os::raw::c_char,
        unicode: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringIsInteger(string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUTF8ToUniChar(
        str_: *const ::std::os::raw::c_char,
        chPtr: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringEscape(pszString: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringInArray(
        pszString: *const ::std::os::raw::c_char,
        array: *mut *mut ::std::os::raw::c_char,
        numelements: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msStringBuffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn msStringBufferAlloc() -> *mut msStringBuffer;
}
extern "C" {
    pub fn msStringBufferFree(sb: *mut msStringBuffer);
}
extern "C" {
    pub fn msStringBufferGetString(sb: *mut msStringBuffer) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringBufferReleaseStringAndFree(
        sb: *mut msStringBuffer,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msStringBufferAppend(
        sb: *mut msStringBuffer,
        pszAppendedString: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringToInt(
        str_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStringToDouble(
        str_: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z17msStdStringEscapeB5cxx11PKc"]
    pub fn msStdStringEscape(pszString: *const ::std::os::raw::c_char) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_Z12msStringTrimRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn msStringTrim1(string: *mut std_string);
}
extern "C" {
    #[link_name = "\u{1}_Z18msStringTrimBlanksRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn msStringTrimBlanks1(string: *mut std_string);
}
extern "C" {
    #[link_name = "\u{1}_Z16msStringTrimLeftRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn msStringTrimLeft1(string: *mut std_string);
}
extern "C" {
    #[link_name = "\u{1}_Z13msStringSplitB5cxx11PKcc"]
    pub fn msStringSplit1(
        string: *const ::std::os::raw::c_char,
        cd: ::std::os::raw::c_char,
    ) -> std_vector;
}
extern "C" {
    #[link_name = "\u{1}_Z15msStringToLowerRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn msStringToLower1(s: *const std_string) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_Z15msStringInArrayPKcRKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EE"]
    pub fn msStringInArray1(
        pszString: *const ::std::os::raw::c_char,
        array: *const std_vector,
    ) -> bool;
}
extern "C" {
    pub fn msStrdup(pszString: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct style_hittest {
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_style_hittest() {
    assert_eq!(
        ::std::mem::size_of::<style_hittest>(),
        4usize,
        concat!("Size of: ", stringify!(style_hittest))
    );
    assert_eq!(
        ::std::mem::align_of::<style_hittest>(),
        4usize,
        concat!("Alignment of ", stringify!(style_hittest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<style_hittest>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(style_hittest),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label_hittest {
    pub stylehits: *mut style_hittest,
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_label_hittest() {
    assert_eq!(
        ::std::mem::size_of::<label_hittest>(),
        16usize,
        concat!("Size of: ", stringify!(label_hittest))
    );
    assert_eq!(
        ::std::mem::align_of::<label_hittest>(),
        8usize,
        concat!("Alignment of ", stringify!(label_hittest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_hittest>())).stylehits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(label_hittest),
            "::",
            stringify!(stylehits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_hittest>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(label_hittest),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct class_hittest {
    pub stylehits: *mut style_hittest,
    pub labelhits: *mut label_hittest,
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_class_hittest() {
    assert_eq!(
        ::std::mem::size_of::<class_hittest>(),
        24usize,
        concat!("Size of: ", stringify!(class_hittest))
    );
    assert_eq!(
        ::std::mem::align_of::<class_hittest>(),
        8usize,
        concat!("Alignment of ", stringify!(class_hittest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<class_hittest>())).stylehits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(class_hittest),
            "::",
            stringify!(stylehits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<class_hittest>())).labelhits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(class_hittest),
            "::",
            stringify!(labelhits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<class_hittest>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(class_hittest),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct layer_hittest {
    pub classhits: *mut class_hittest,
    pub status: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_layer_hittest() {
    assert_eq!(
        ::std::mem::size_of::<layer_hittest>(),
        16usize,
        concat!("Size of: ", stringify!(layer_hittest))
    );
    assert_eq!(
        ::std::mem::align_of::<layer_hittest>(),
        8usize,
        concat!("Alignment of ", stringify!(layer_hittest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer_hittest>())).classhits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(layer_hittest),
            "::",
            stringify!(classhits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<layer_hittest>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(layer_hittest),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct map_hittest {
    pub layerhits: *mut layer_hittest,
}
#[test]
fn bindgen_test_layout_map_hittest() {
    assert_eq!(
        ::std::mem::size_of::<map_hittest>(),
        8usize,
        concat!("Size of: ", stringify!(map_hittest))
    );
    assert_eq!(
        ::std::mem::align_of::<map_hittest>(),
        8usize,
        concat!("Alignment of ", stringify!(map_hittest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<map_hittest>())).layerhits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(map_hittest),
            "::",
            stringify!(layerhits)
        )
    );
}
extern "C" {
    pub fn msHitTestMap(map: *mut mapObj, hittest: *mut map_hittest) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msHitTestLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        hittest: *mut layer_hittest,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadSymbolSet(symbolset: *mut symbolSetObj, map: *mut mapObj)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopySymbol(
        dst: *mut symbolObj,
        src: *const symbolObj,
        map: *mut mapObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopySymbolSet(
        dst: *mut symbolSetObj,
        src: *const symbolSetObj,
        map: *mut mapObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyHashTable(
        dst: *mut hashTableObj,
        src: *const hashTableObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitSymbolSet(symbolset: *mut symbolSetObj);
}
extern "C" {
    pub fn msGrowSymbolSet(symbolset: *mut symbolSetObj) -> *mut symbolObj;
}
extern "C" {
    pub fn msAddImageSymbol(
        symbolset: *mut symbolSetObj,
        filename: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeSymbolSet(symbolset: *mut symbolSetObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeSymbol(symbol: *mut symbolObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddNewSymbol(
        map: *mut mapObj,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAppendSymbol(
        symbolset: *mut symbolSetObj,
        symbol: *mut symbolObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveSymbol(
        symbolset: *mut symbolSetObj,
        index: ::std::os::raw::c_int,
    ) -> *mut symbolObj;
}
extern "C" {
    pub fn msSaveSymbolSet(
        symbolset: *mut symbolSetObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadImageSymbol(
        symbol: *mut symbolObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPreloadImageSymbol(
        renderer: *mut rendererVTableObj,
        symbol: *mut symbolObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPreloadSVGSymbol(symbol: *mut symbolObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRotateSymbol(symbol: *mut symbolObj, angle: f64) -> *mut symbolObj;
}
extern "C" {
    pub fn msGetCharacterSize(
        map: *mut mapObj,
        font: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        character: *mut ::std::os::raw::c_char,
        r: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetMarkerSize(
        map: *mut mapObj,
        style: *mut styleObj,
        width: *mut f64,
        height: *mut f64,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSymbolGetDefaultSize(s: *mut symbolObj) -> f64;
}
extern "C" {
    pub fn msDrawLegend(
        map: *mut mapObj,
        scale_independent: ::std::os::raw::c_int,
        hittest: *mut map_hittest,
    ) -> *mut imageObj;
}
extern "C" {
    pub fn msLegendCalcSize(
        map: *mut mapObj,
        scale_independent: ::std::os::raw::c_int,
        size_x: *mut ::std::os::raw::c_int,
        size_y: *mut ::std::os::raw::c_int,
        alayers: *mut ::std::os::raw::c_int,
        numl_ayer: ::std::os::raw::c_int,
        hittest: *mut map_hittest,
        resolutionfactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEmbedLegend(map: *mut mapObj, img: *mut imageObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawLegendIcon(
        map: *mut mapObj,
        lp: *mut layerObj,
        myClass: *mut classObj,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        img: *mut imageObj,
        dstX: ::std::os::raw::c_int,
        dstY: ::std::os::raw::c_int,
        scale_independant: ::std::os::raw::c_int,
        hittest: *mut class_hittest,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCreateLegendIcon(
        map: *mut mapObj,
        lp: *mut layerObj,
        myClass: *mut classObj,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        scale_independant: ::std::os::raw::c_int,
    ) -> *mut imageObj;
}
extern "C" {
    pub fn msLoadFontSet(fontSet: *mut fontSetObj, map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitFontSet(fontset: *mut fontSetObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeFontSet(fontset: *mut fontSetObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetTextSymbolSize(
        map: *mut mapObj,
        ts: *mut textSymbolObj,
        r: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetStringSize(
        map: *mut mapObj,
        label: *mut labelObj,
        size: ::std::os::raw::c_int,
        string: *mut ::std::os::raw::c_char,
        r: *mut rectObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddLabel(
        map: *mut mapObj,
        image: *mut imageObj,
        label: *mut labelObj,
        layerindex: ::std::os::raw::c_int,
        classindex: ::std::os::raw::c_int,
        shape: *mut shapeObj,
        point: *mut pointObj,
        featuresize: f64,
        ts: *mut textSymbolObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddLabelGroup(
        map: *mut mapObj,
        image: *mut imageObj,
        layer: *mut layerObj,
        classindex: ::std::os::raw::c_int,
        shape: *mut shapeObj,
        point: *mut pointObj,
        featuresize: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msTestLabelCacheCollisions(
        map: *mut mapObj,
        cachePtr: *mut labelCacheMemberObj,
        lb: *mut label_bounds,
        current_priority: ::std::os::raw::c_int,
        current_label: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msTestLabelCacheLeaderCollision(
        map: *mut mapObj,
        lp1: *mut pointObj,
        lp2: *mut pointObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetLabelCacheMember(
        labelcache: *mut labelCacheObj,
        i: ::std::os::raw::c_int,
    ) -> *mut labelCacheMemberObj;
}
extern "C" {
    pub fn msFreeShape(shape: *mut shapeObj);
}
extern "C" {
    pub fn msGetShapeRAMSize(shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeLabelPathObj(path: *mut labelPathObj);
}
extern "C" {
    pub fn msShapeFromWKT(string: *const ::std::os::raw::c_char) -> *mut shapeObj;
}
extern "C" {
    pub fn msShapeToWKT(shape: *mut shapeObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msInitShape(shape: *mut shapeObj);
}
extern "C" {
    pub fn msShapeDeleteLine(shape: *mut shapeObj, line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msCopyShape(from: *const shapeObj, to: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msIsOuterRing(shape: *mut shapeObj, r: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetOuterList(shape: *mut shapeObj) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetInnerList(
        shape: *mut shapeObj,
        r: ::std::os::raw::c_int,
        outerlist: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msComputeBounds(shape: *mut shapeObj);
}
extern "C" {
    pub fn msRectToPolygon(rect: rectObj, poly: *mut shapeObj);
}
extern "C" {
    pub fn msClipPolylineRect(shape: *mut shapeObj, rect: rectObj);
}
extern "C" {
    pub fn msClipPolygonRect(shape: *mut shapeObj, rect: rectObj);
}
extern "C" {
    pub fn msTransformShape(
        shape: *mut shapeObj,
        extent: rectObj,
        cellsize: f64,
        image: *mut imageObj,
    );
}
extern "C" {
    pub fn msTransformPoint(
        point: *mut pointObj,
        extent: *mut rectObj,
        cellsize: f64,
        image: *mut imageObj,
    );
}
extern "C" {
    pub fn msOffsetPointRelativeTo(point: *mut pointObj, layer: *mut layerObj);
}
extern "C" {
    pub fn msOffsetShapeRelativeTo(shape: *mut shapeObj, layer: *mut layerObj);
}
extern "C" {
    pub fn msTransformShapeSimplify(shape: *mut shapeObj, extent: rectObj, cellsize: f64);
}
extern "C" {
    pub fn msTransformShapeToPixelSnapToGrid(
        shape: *mut shapeObj,
        extent: rectObj,
        cellsize: f64,
        grid_resolution: f64,
    );
}
extern "C" {
    pub fn msTransformShapeToPixelRound(shape: *mut shapeObj, extent: rectObj, cellsize: f64);
}
extern "C" {
    pub fn msTransformShapeToPixelDoublePrecision(
        shape: *mut shapeObj,
        extent: rectObj,
        cellsize: f64,
    );
}
extern "C" {
    pub fn msDensify(shape: *mut shapeObj, tolerance: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msRings2Shape(shape: *mut shapeObj, outer: ::std::os::raw::c_int) -> *mut shapeObj;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct line_lengths {
    pub segment_lengths: *mut f64,
    pub total_length: f64,
    pub longest_segment_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_line_lengths() {
    assert_eq!(
        ::std::mem::size_of::<line_lengths>(),
        24usize,
        concat!("Size of: ", stringify!(line_lengths))
    );
    assert_eq!(
        ::std::mem::align_of::<line_lengths>(),
        8usize,
        concat!("Alignment of ", stringify!(line_lengths))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<line_lengths>())).segment_lengths as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(line_lengths),
            "::",
            stringify!(segment_lengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<line_lengths>())).total_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(line_lengths),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<line_lengths>())).longest_segment_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(line_lengths),
            "::",
            stringify!(longest_segment_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct polyline_lengths {
    pub ll: *mut line_lengths,
    pub total_length: f64,
    pub longest_line_index: ::std::os::raw::c_int,
    pub longest_segment_line_index: ::std::os::raw::c_int,
    pub longest_segment_point_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_polyline_lengths() {
    assert_eq!(
        ::std::mem::size_of::<polyline_lengths>(),
        32usize,
        concat!("Size of: ", stringify!(polyline_lengths))
    );
    assert_eq!(
        ::std::mem::align_of::<polyline_lengths>(),
        8usize,
        concat!("Alignment of ", stringify!(polyline_lengths))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<polyline_lengths>())).ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(polyline_lengths),
            "::",
            stringify!(ll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<polyline_lengths>())).total_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(polyline_lengths),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<polyline_lengths>())).longest_line_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(polyline_lengths),
            "::",
            stringify!(longest_line_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<polyline_lengths>())).longest_segment_line_index as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(polyline_lengths),
            "::",
            stringify!(longest_segment_line_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<polyline_lengths>())).longest_segment_point_index as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(polyline_lengths),
            "::",
            stringify!(longest_segment_point_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label_auto_result {
    pub label_points: *mut pointObj,
    pub angles: *mut f64,
    pub num_label_points: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_label_auto_result() {
    assert_eq!(
        ::std::mem::size_of::<label_auto_result>(),
        24usize,
        concat!("Size of: ", stringify!(label_auto_result))
    );
    assert_eq!(
        ::std::mem::align_of::<label_auto_result>(),
        8usize,
        concat!("Alignment of ", stringify!(label_auto_result))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_auto_result>())).label_points as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(label_auto_result),
            "::",
            stringify!(label_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_auto_result>())).angles as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(label_auto_result),
            "::",
            stringify!(angles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<label_auto_result>())).num_label_points as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(label_auto_result),
            "::",
            stringify!(num_label_points)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label_follow_result {
    pub follow_labels: *mut *mut textSymbolObj,
    pub num_follow_labels: ::std::os::raw::c_int,
    pub lar: label_auto_result,
}
#[test]
fn bindgen_test_layout_label_follow_result() {
    assert_eq!(
        ::std::mem::size_of::<label_follow_result>(),
        40usize,
        concat!("Size of: ", stringify!(label_follow_result))
    );
    assert_eq!(
        ::std::mem::align_of::<label_follow_result>(),
        8usize,
        concat!("Alignment of ", stringify!(label_follow_result))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<label_follow_result>())).follow_labels as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(label_follow_result),
            "::",
            stringify!(follow_labels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<label_follow_result>())).num_follow_labels as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(label_follow_result),
            "::",
            stringify!(num_follow_labels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<label_follow_result>())).lar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(label_follow_result),
            "::",
            stringify!(lar)
        )
    );
}
extern "C" {
    pub fn msTransformPixelToShape(shape: *mut shapeObj, extent: rectObj, cellsize: f64);
}
extern "C" {
    pub fn msPolylineComputeLineSegments(shape: *mut shapeObj, pll: *mut polyline_lengths);
}
extern "C" {
    pub fn msPolylineLabelPath(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut shapeObj,
        ts: *mut textSymbolObj,
        label: *mut labelObj,
        lfr: *mut label_follow_result,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPolylineLabelPoint(
        map: *mut mapObj,
        p: *mut shapeObj,
        ts: *mut textSymbolObj,
        label: *mut labelObj,
        lar: *mut label_auto_result,
        resolutionfactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLineLabelPath(
        map: *mut mapObj,
        img: *mut imageObj,
        p: *mut lineObj,
        ts: *mut textSymbolObj,
        ll: *mut line_lengths,
        lfr: *mut label_follow_result,
        lbl: *mut labelObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLineLabelPoint(
        map: *mut mapObj,
        p: *mut lineObj,
        ts: *mut textSymbolObj,
        ll: *mut line_lengths,
        lar: *mut label_auto_result,
        lbl: *mut labelObj,
        resolutionfactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPolygonLabelPoint(
        p: *mut shapeObj,
        lp: *mut pointObj,
        min_dimension: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddLine(p: *mut shapeObj, new_line: *const lineObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddLineDirectly(p: *mut shapeObj, new_line: *mut lineObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddPointToLine(line: *mut lineObj, point: *mut pointObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetPolygonArea(p: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msGetPolygonCentroid(
        p: *mut shapeObj,
        lp: *mut pointObj,
        miny: *mut f64,
        maxy: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawRasterLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawReferenceMap(map: *mut mapObj) -> *mut imageObj;
}
extern "C" {
    pub fn msGetBitArraySize(numbits: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn msAllocBitArray(numbits: ::std::os::raw::c_int) -> ms_bitarray;
}
extern "C" {
    pub fn msGetBit(
        array: ms_const_bitarray,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSetBit(array: ms_bitarray, index: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msSetAllBits(
        array: ms_bitarray,
        index: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msFlipBit(array: ms_bitarray, index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msGetNextBit(
        array: ms_const_bitarray,
        index: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerInitItemInfo(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerFreeItemInfo(layer: *mut layerObj);
}
extern "C" {
    pub fn msLayerOpen(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerApplyScaletokens(layer: *mut layerObj, scale: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerRestoreFromScaletokens(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msClusterLayerOpen(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerIsOpen(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerClose(layer: *mut layerObj);
}
extern "C" {
    pub fn msLayerFreeExpressions(layer: *mut layerObj);
}
extern "C" {
    pub fn msLayerWhichShapes(
        layer: *mut layerObj,
        rect: rectObj,
        isQuery: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetItemIndex(
        layer: *mut layerObj,
        item: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerWhichItems(
        layer: *mut layerObj,
        get_all: ::std::os::raw::c_int,
        metadata: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerNextShape(layer: *mut layerObj, shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetItems(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSetItems(
        layer: *mut layerObj,
        items: *mut *mut ::std::os::raw::c_char,
        numitems: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetShape(
        layer: *mut layerObj,
        shape: *mut shapeObj,
        record: *mut resultObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetShapeCount(
        layer: *mut layerObj,
        rect: rectObj,
        rectProjection: *mut projectionObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetExtent(layer: *mut layerObj, extent: *mut rectObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSetExtent(
        layer: *mut layerObj,
        minx: f64,
        miny: f64,
        maxx: f64,
        maxy: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetAutoStyle(
        map: *mut mapObj,
        layer: *mut layerObj,
        c: *mut classObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetFeatureStyle(
        map: *mut mapObj,
        layer: *mut layerObj,
        c: *mut classObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerAddProcessing(layer: *mut layerObj, directive: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn msLayerSetProcessingKey(
        layer: *mut layerObj,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msLayerGetProcessing(
        layer: *const layerObj,
        proc_index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msLayerGetProcessingKey(
        layer: *const layerObj,
        arg1: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msLayerClearProcessing(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSubstituteProcessing(
        layer: *mut layerObj,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msLayerGetFilterString(layer: *mut layerObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msLayerEncodeShapeAttributes(
        layer: *mut layerObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerTranslateFilter(
        layer: *mut layerObj,
        filter: *mut expressionObj,
        filteritem: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSupportsCommonFilters(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msExpressionTokenToString(token: ::std::os::raw::c_int)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTokenizeExpression(
        expression: *mut expressionObj,
        list: *mut *mut ::std::os::raw::c_char,
        listsize: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSetTimeFilter(
        lp: *mut layerObj,
        timestring: *const ::std::os::raw::c_char,
        timefield: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerMakeBackticsTimeFilter(
        lp: *mut layerObj,
        timestring: *const ::std::os::raw::c_char,
        timefield: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerMakePlainTimeFilter(
        lp: *mut layerObj,
        timestring: *const ::std::os::raw::c_char,
        timefield: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerApplyCondSQLFilterToLayer(
        psNode: *mut FilterEncodingNode,
        map: *mut mapObj,
        iLayerIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerApplyPlainFilterToLayer(
        psNode: *mut FilterEncodingNode,
        map: *mut mapObj,
        iLayerIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetNumFeatures(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSupportsPaging(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerEnablePaging(layer: *mut layerObj, value: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msLayerGetPaging(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerGetMaxFeaturesToDraw(
        layer: *mut layerObj,
        format: *mut outputFormatObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerEscapeSQLParam(
        layer: *mut layerObj,
        pszString: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msLayerEscapePropertyName(
        layer: *mut layerObj,
        pszString: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msLayerSupportsSorting(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLayerSetSort(layer: *mut layerObj, sortBy: *const sortByClause);
}
extern "C" {
    pub fn msLayerBuildSQLOrderBy(layer: *mut layerObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msOGRLayerNextShape(layer: *mut layerObj, shape: *mut shapeObj)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerGetItems(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerFreeItemInfo(layer: *mut layerObj);
}
extern "C" {
    pub fn msOGRLayerGetShape(
        layer: *mut layerObj,
        shape: *mut shapeObj,
        record: *mut resultObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerGetExtent(layer: *mut layerObj, extent: *mut rectObj)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRGeometryToShape(
        hGeometry: OGRGeometryH,
        shape: *mut shapeObj,
        type_: OGRwkbGeometryType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msConnectLayer(
        layer: *mut layerObj,
        connectiontype: ::std::os::raw::c_int,
        library_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msINLINELayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSHPLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFlatGeobufLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msTiledSHPLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPostGISLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOracleSpatialLayerInitializeVirtualTable(
        layer: *mut layerObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msWFSLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGraticuleLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRASTERLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUVRASTERLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msContourLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPluginLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msUnionLayerInitializeVirtualTable(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPluginFreeVirtualTableFactory();
}
extern "C" {
    pub fn msUVRASTERLayerUseMapExtentAndProjectionForNextWhichShapes(
        layer: *mut layerObj,
        map: *mut mapObj,
    );
}
extern "C" {
    pub fn msUVRASTERGetSearchRect(layer: *mut layerObj, map: *mut mapObj) -> rectObj;
}
extern "C" {
    pub fn msPrepareImage(
        map: *mut mapObj,
        allow_nonsquare: ::std::os::raw::c_int,
    ) -> *mut imageObj;
}
extern "C" {
    pub fn msDrawMap(map: *mut mapObj, querymap: ::std::os::raw::c_int) -> *mut imageObj;
}
extern "C" {
    pub fn msLayerIsVisible(map: *mut mapObj, layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawVectorLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawQueryLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawWMSLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawWFSLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawShape(
        map: *mut mapObj,
        layer: *mut layerObj,
        shape: *mut shapeObj,
        image: *mut imageObj,
        style: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawPoint(
        map: *mut mapObj,
        layer: *mut layerObj,
        point: *mut pointObj,
        image: *mut imageObj,
        classindex: ::std::os::raw::c_int,
        labeltext: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const colorspace_MS_COLORSPACE_RGB: colorspace = 0;
pub const colorspace_MS_COLORSPACE_HSL: colorspace = 1;
pub type colorspace = ::std::os::raw::c_uint;
extern "C" {
    pub fn msShapeToRange(style: *mut styleObj, shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msValueToRange(
        style: *mut styleObj,
        fieldVal: f64,
        cs: colorspace,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawMarkerSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut pointObj,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawLineSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut shapeObj,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawShadeSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut shapeObj,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCircleDrawLineSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut pointObj,
        r: f64,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCircleDrawShadeSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut pointObj,
        r: f64,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawPieSlice(
        map: *mut mapObj,
        image: *mut imageObj,
        p: *mut pointObj,
        style: *mut styleObj,
        radius: f64,
        start: f64,
        end: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawLabelBounds(
        map: *mut mapObj,
        image: *mut imageObj,
        bnds: *mut label_bounds,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOutlineRenderingPrepareStyle(
        pStyle: *mut styleObj,
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    );
}
extern "C" {
    pub fn msOutlineRenderingRestoreStyle(
        pStyle: *mut styleObj,
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    );
}
extern "C" {
    pub fn msDrawLabel(
        map: *mut mapObj,
        image: *mut imageObj,
        labelPnt: pointObj,
        string: *mut ::std::os::raw::c_char,
        label: *mut labelObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawTextSymbol(
        map: *mut mapObj,
        image: *mut imageObj,
        labelPnt: pointObj,
        ts: *mut textSymbolObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawLabelCache(map: *mut mapObj, image: *mut imageObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msImageStartLayer(map: *mut mapObj, layer: *mut layerObj, image: *mut imageObj);
}
extern "C" {
    pub fn msImageEndLayer(map: *mut mapObj, layer: *mut layerObj, image: *mut imageObj);
}
extern "C" {
    pub fn msDrawStartShape(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
        shape: *mut shapeObj,
    );
}
extern "C" {
    pub fn msDrawEndShape(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
        shape: *mut shapeObj,
    );
}
extern "C" {
    pub fn msRasterizeArc(
        x0: f64,
        y0: f64,
        radius: f64,
        startAngle: f64,
        endAngle: f64,
        isSlice: ::std::os::raw::c_int,
    ) -> *mut shapeObj;
}
extern "C" {
    pub fn msHatchPolygon(
        img: *mut imageObj,
        poly: *mut shapeObj,
        spacing: f64,
        width: f64,
        pattern: *mut f64,
        patternlength: ::std::os::raw::c_int,
        angle: f64,
        color: *mut colorObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msImageCreateIM(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: *mut outputFormatObj,
        imagepath: *mut ::std::os::raw::c_char,
        imageurl: *mut ::std::os::raw::c_char,
        resolution: f64,
        defresolution: f64,
    ) -> *mut imageObj;
}
extern "C" {
    pub fn msImageStartLayerIM(map: *mut mapObj, layer: *mut layerObj, image: *mut imageObj);
}
extern "C" {
    pub fn msSaveImageIM(
        img: *mut imageObj,
        filename: *const ::std::os::raw::c_char,
        format: *mut outputFormatObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeImageIM(img: *mut imageObj);
}
extern "C" {
    pub fn msDrawMarkerSymbolIM(
        map: *mut mapObj,
        img: *mut imageObj,
        p: *mut pointObj,
        style: *mut styleObj,
        scalefactor: f64,
    );
}
extern "C" {
    pub fn msDrawLineSymbolIM(
        map: *mut mapObj,
        img: *mut imageObj,
        p: *mut shapeObj,
        style: *mut styleObj,
        scalefactor: f64,
    );
}
extern "C" {
    pub fn msDrawShadeSymbolIM(
        map: *mut mapObj,
        img: *mut imageObj,
        p: *mut shapeObj,
        style: *mut styleObj,
        scalefactor: f64,
    );
}
extern "C" {
    pub fn msDrawTextIM(
        map: *mut mapObj,
        img: *mut imageObj,
        labelPnt: pointObj,
        string: *mut ::std::os::raw::c_char,
        label: *mut labelObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msJoinConnect(layer: *mut layerObj, join: *mut joinObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msJoinPrepare(join: *mut joinObj, shape: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msJoinNext(join: *mut joinObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msJoinClose(join: *mut joinObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawRasterLayerLowCheckIfMustDraw(
        map: *mut mapObj,
        layer: *mut layerObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawRasterLayerLowOpenDataset(
        map: *mut mapObj,
        layer: *mut layerObj,
        filename: *const ::std::os::raw::c_char,
        szPath: *mut ::std::os::raw::c_char,
        p_decrypted_path: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msDrawRasterLayerLowCloseDataset(
        layer: *mut layerObj,
        hDataset: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn msDrawRasterLayerLowWithDataset(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
        rb: *mut rasterBufferObj,
        hDatasetIn: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawRasterLayerLow(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
        rb: *mut rasterBufferObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetClass(
        layer: *mut layerObj,
        color: *mut colorObj,
        colormap_index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetClass_FloatRGB(
        layer: *mut layerObj,
        fValue: f32,
        red: ::std::os::raw::c_int,
        green: ::std::os::raw::c_int,
        blue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetClass_FloatRGB_WithFirstClassToTry(
        layer: *mut layerObj,
        fValue: f32,
        red: ::std::os::raw::c_int,
        green: ::std::os::raw::c_int,
        blue: ::std::os::raw::c_int,
        firstClassToTry: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawRasterLayerGDAL(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
        rb: *mut rasterBufferObj,
        hDSVoid: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetGDALGeoTransform(
        hDS: *mut ::std::os::raw::c_void,
        map: *mut mapObj,
        layer: *mut layerObj,
        padfGeoTransform: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetGDALBandList(
        layer: *mut layerObj,
        hDS: *mut ::std::os::raw::c_void,
        max_bands: ::std::os::raw::c_int,
        band_count: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetGDALNoDataValue(
        layer: *mut layerObj,
        hBand: *mut ::std::os::raw::c_void,
        pbGotNoData: *mut ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn msInterpolationDataset(
        map: *mut mapObj,
        image: *mut imageObj,
        layer: *mut layerObj,
        hDSvoid: *mut *mut ::std::os::raw::c_void,
        cleanup_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCleanupInterpolationDataset(
        map: *mut mapObj,
        image: *mut imageObj,
        layer: *mut layerObj,
        cleanup_ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawChartLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        image: *mut imageObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msScaleInBounds(scale: f64, minscale: f64, maxscale: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSmallMalloc(nSize: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msSmallRealloc(
        pData: *mut ::std::os::raw::c_void,
        nNewSize: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msSmallCalloc(nCount: size_t, nSize: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msIntegerInArray(
        value: ::std::os::raw::c_int,
        array: *mut ::std::os::raw::c_int,
        numelements: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msExtentsOverlap(map: *mut mapObj, layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msBuildOnlineResource(
        map: *mut mapObj,
        req: *mut cgiRequestObj,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msBindLayerToShape(
        layer: *mut layerObj,
        shape: *mut shapeObj,
        querymapMode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msValidateContexts(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEvalContext(
        map: *mut mapObj,
        layer: *mut layerObj,
        context: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEvalExpression(
        layer: *mut layerObj,
        shape: *mut shapeObj,
        expression: *mut expressionObj,
        itemindex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapeGetClass(
        layer: *mut layerObj,
        map: *mut mapObj,
        shape: *mut shapeObj,
        classgroup: *mut ::std::os::raw::c_int,
        numclasses: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapeGetNextClass(
        currentclass: ::std::os::raw::c_int,
        layer: *mut layerObj,
        map: *mut mapObj,
        shape: *mut shapeObj,
        classgroup: *mut ::std::os::raw::c_int,
        numclasses: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapeCheckSize(shape: *mut shapeObj, minfeaturesize: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msShapeGetLabelAnnotation(
        layer: *mut layerObj,
        shape: *mut shapeObj,
        lbl: *mut labelObj,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msGetLabelStatus(
        map: *mut mapObj,
        layer: *mut layerObj,
        shape: *mut shapeObj,
        lbl: *mut labelObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAdjustImage(
        rect: rectObj,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEvalTextExpression(
        expr: *mut expressionObj,
        shape: *mut shapeObj,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msEvalTextExpressionJSonEscape(
        expr: *mut expressionObj,
        shape: *mut shapeObj,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msEvalDoubleExpression(expr: *mut expressionObj, shape: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msAdjustExtent(
        rect: *mut rectObj,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn msConstrainExtent(
        bounds: *mut rectObj,
        rect: *mut rectObj,
        overlay: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGetLayersIndexByGroup(
        map: *mut mapObj,
        groupname: *mut ::std::os::raw::c_char,
        nCount: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSaveImageBuffer(
        image: *mut imageObj,
        size_ptr: *mut ::std::os::raw::c_int,
        format: *mut outputFormatObj,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn msOffsetPolyline(shape: *mut shapeObj, offsetx: f64, offsety: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msMapSetLayerProjections(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveLayerUp(
        map: *mut mapObj,
        nLayerIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveLayerDown(
        map: *mut mapObj,
        nLayerIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSetLayersdrawingOrder(
        self_: *mut mapObj,
        panIndexes: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInsertLayer(
        map: *mut mapObj,
        layer: *mut layerObj,
        nIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveLayer(map: *mut mapObj, nIndex: ::std::os::raw::c_int) -> *mut layerObj;
}
extern "C" {
    pub fn msInsertClass(
        layer: *mut layerObj,
        classobj: *mut classObj,
        nIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveClass(layer: *mut layerObj, nIndex: ::std::os::raw::c_int) -> *mut classObj;
}
extern "C" {
    pub fn msMoveClassUp(
        layer: *mut layerObj,
        nClassIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveClassDown(
        layer: *mut layerObj,
        nClassIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAddLabelToClass(classo: *mut classObj, label: *mut labelObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveLabelFromClass(
        classo: *mut classObj,
        nLabelIndex: ::std::os::raw::c_int,
    ) -> *mut labelObj;
}
extern "C" {
    pub fn msMoveStyleUp(
        classo: *mut classObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveStyleDown(
        classo: *mut classObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDeleteStyle(
        classo: *mut classObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInsertStyle(
        classo: *mut classObj,
        style: *mut styleObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveStyle(classo: *mut classObj, index: ::std::os::raw::c_int) -> *mut styleObj;
}
extern "C" {
    pub fn msInsertLabelStyle(
        label: *mut labelObj,
        style: *mut styleObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveLabelStyleUp(
        label: *mut labelObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMoveLabelStyleDown(
        label: *mut labelObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDeleteLabelStyle(
        label: *mut labelObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveLabelStyle(
        label: *mut labelObj,
        nStyleIndex: ::std::os::raw::c_int,
    ) -> *mut styleObj;
}
extern "C" {
    pub fn msGetPointUsingMeasure(shape: *mut shapeObj, m: f64) -> *mut pointObj;
}
extern "C" {
    pub fn msGetMeasureUsingPoint(shape: *mut shapeObj, point: *mut pointObj) -> *mut pointObj;
}
extern "C" {
    pub fn msGetAllGroupNames(
        map: *mut mapObj,
        numTok: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTmpFile(
        map: *mut mapObj,
        mappath: *const ::std::os::raw::c_char,
        tmppath: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTmpPath(
        map: *mut mapObj,
        mappath: *const ::std::os::raw::c_char,
        tmppath: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msTmpFilename(ext: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msForceTmpFileBase(new_base: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn msImageCreate(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: *mut outputFormatObj,
        imagepath: *mut ::std::os::raw::c_char,
        imageurl: *mut ::std::os::raw::c_char,
        resolution: f64,
        defresolution: f64,
        bg: *mut colorObj,
    ) -> *mut imageObj;
}
extern "C" {
    pub fn msAlphaBlend(
        red_src: ::std::os::raw::c_uchar,
        green_src: ::std::os::raw::c_uchar,
        blue_src: ::std::os::raw::c_uchar,
        alpha_src: ::std::os::raw::c_uchar,
        red_dst: *mut ::std::os::raw::c_uchar,
        green_dst: *mut ::std::os::raw::c_uchar,
        blue_dst: *mut ::std::os::raw::c_uchar,
        alpha_dst: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn msAlphaBlendPM(
        red_src: ::std::os::raw::c_uchar,
        green_src: ::std::os::raw::c_uchar,
        blue_src: ::std::os::raw::c_uchar,
        alpha_src: ::std::os::raw::c_uchar,
        red_dst: *mut ::std::os::raw::c_uchar,
        green_dst: *mut ::std::os::raw::c_uchar,
        blue_dst: *mut ::std::os::raw::c_uchar,
        alpha_dst: *mut ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn msRGBtoHSL(rgb: *mut colorObj, h: *mut f64, s: *mut f64, l: *mut f64);
}
extern "C" {
    pub fn msHSLtoRGB(h: f64, s: f64, l: f64, rgb: *mut colorObj);
}
extern "C" {
    pub fn msCheckParentPointer(
        p: *mut ::std::os::raw::c_void,
        objname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAllocateValidClassGroups(
        lp: *mut layerObj,
        nclasses: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn msFreeRasterBuffer(b: *mut rasterBufferObj);
}
extern "C" {
    pub fn msSetLayerOpacity(layer: *mut layerObj, opacity: ::std::os::raw::c_int);
}
extern "C" {
    pub fn msMapSetLanguageSpecificConnection(
        map: *mut mapObj,
        validated_language: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msGeneralize(shape: *mut shapeObj, tolerance: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msApplyDefaultOutputFormats(arg1: *mut mapObj);
}
extern "C" {
    pub fn msFreeOutputFormat(arg1: *mut outputFormatObj);
}
extern "C" {
    pub fn msGetOutputFormatIndex(
        map: *mut mapObj,
        imagetype: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msRemoveOutputFormat(
        map: *mut mapObj,
        imagetype: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msAppendOutputFormat(
        map: *mut mapObj,
        format: *mut outputFormatObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSelectOutputFormat(
        map: *mut mapObj,
        imagetype: *const ::std::os::raw::c_char,
    ) -> *mut outputFormatObj;
}
extern "C" {
    pub fn msApplyOutputFormat(
        target: *mut *mut outputFormatObj,
        format: *mut outputFormatObj,
        transparent: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msGetOutputFormatOption(
        format: *mut outputFormatObj,
        optionkey: *const ::std::os::raw::c_char,
        defaultresult: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msCreateDefaultOutputFormat(
        map: *mut mapObj,
        driver: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        mimetype: *const ::std::os::raw::c_char,
    ) -> *mut outputFormatObj;
}
extern "C" {
    pub fn msPostMapParseOutputFormatSetup(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSetOutputFormatOption(
        format: *mut outputFormatObj,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msGetOutputFormatMimeList(
        map: *mut mapObj,
        mime_list: *mut *mut ::std::os::raw::c_char,
        max_mime: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msGetOutputFormatMimeListImg(
        map: *mut mapObj,
        mime_list: *mut *const ::std::os::raw::c_char,
        max_mime: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msGetOutputFormatMimeListWMS(
        map: *mut mapObj,
        mime_list: *mut *const ::std::os::raw::c_char,
        max_mime: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msCloneOutputFormat(format: *mut outputFormatObj) -> *mut outputFormatObj;
}
extern "C" {
    pub fn msOutputFormatValidate(
        format: *mut outputFormatObj,
        issue_error: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOutputFormatResolveFromImage(map: *mut mapObj, img: *mut imageObj);
}
extern "C" {
    pub fn msSaveImageGDAL(
        map: *mut mapObj,
        image: *mut imageObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitDefaultGDALOutputFormat(format: *mut outputFormatObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCleanVSIDir(pszDir: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn msGetStringListFromHashTable(
        table: *mut hashTableObj,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msInitDefaultOGROutputFormat(format: *mut outputFormatObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRWriteFromQuery(
        map: *mut mapObj,
        format: *mut outputFormatObj,
        sendheaders: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerWhichShapes(
        layer: *mut layerObj,
        rect: rectObj,
        isQuery: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerOpen(
        layer: *mut layerObj,
        pszOverrideConnection: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRLayerClose(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOGRShapeToWKT(shape: *mut shapeObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msOGRShapeFromWKT(string: *const ::std::os::raw::c_char) -> *mut shapeObj;
}
extern "C" {
    pub fn msOGRUpdateStyleFromString(
        map: *mut mapObj,
        layer: *mut layerObj,
        c: *mut classObj,
        stylestring: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyMap(dst: *mut mapObj, src: *const mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyLayer(dst: *mut layerObj, src: *const layerObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyScaleToken(
        src: *const scaleTokenObj,
        dst: *mut scaleTokenObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyPoint(dst: *mut pointObj, src: *const pointObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyFontSet(
        dst: *mut fontSetObj,
        src: *const fontSetObj,
        map: *mut mapObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyClass(
        dst: *mut classObj,
        src: *const classObj,
        layer: *mut layerObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyStyle(dst: *mut styleObj, src: *const styleObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyLabel(dst: *mut labelObj, src: *const labelObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyLabelLeader(
        dst: *mut labelLeaderObj,
        src: *const labelLeaderObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyLine(dst: *mut lineObj, src: *const lineObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyProjection(
        dst: *mut projectionObj,
        src: *const projectionObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyProjectionExtended(
        dst: *mut projectionObj,
        src: *const projectionObj,
        args: *mut *mut ::std::os::raw::c_char,
        num_args: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyExpression(
        dst: *mut expressionObj,
        src: *const expressionObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCopyRasterBuffer(
        dst: *mut rasterBufferObj,
        src: *const rasterBufferObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msConnPoolRequest(layer: *mut layerObj) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msConnPoolRelease(layer: *mut layerObj, arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn msConnPoolRegister(
        layer: *mut layerObj,
        conn_handle: *mut ::std::os::raw::c_void,
        close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn msConnPoolCloseUnreferenced();
}
extern "C" {
    pub fn msConnPoolFinalCleanup();
}
extern "C" {
    pub fn msGetBasename(
        pszFullFilename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn msGetSymbol(
        pszLibrary: *const ::std::os::raw::c_char,
        pszEntryPoint: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn msGEOSSetup();
}
extern "C" {
    pub fn msGEOSCleanup();
}
extern "C" {
    pub fn msGEOSFreeGeometry(shape: *mut shapeObj);
}
extern "C" {
    pub fn msGEOSShapeFromWKT(string: *const ::std::os::raw::c_char) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSShapeToWKT(shape: *mut shapeObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msGEOSFreeWKT(pszGEOSWKT: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msGEOSBuffer(shape: *mut shapeObj, width: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSSimplify(shape: *mut shapeObj, tolerance: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSTopologyPreservingSimplify(shape: *mut shapeObj, tolerance: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSConvexHull(shape: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSBoundary(shape: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSGetCentroid(shape: *mut shapeObj) -> *mut pointObj;
}
extern "C" {
    pub fn msGEOSUnion(shape1: *mut shapeObj, shape2: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSIntersection(shape1: *mut shapeObj, shape2: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSDifference(shape1: *mut shapeObj, shape2: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSSymDifference(shape1: *mut shapeObj, shape2: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSOffsetCurve(p: *mut shapeObj, offset: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSVoronoiDiagram(
        shape: *mut shapeObj,
        tolerance: f64,
        onlyEdges: ::std::os::raw::c_int,
    ) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSCenterline(shape: *mut shapeObj) -> *mut shapeObj;
}
extern "C" {
    pub fn msGEOSContains(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSOverlaps(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSWithin(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSCrosses(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSIntersects(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSTouches(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSEquals(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSDisjoint(shape1: *mut shapeObj, shape2: *mut shapeObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGEOSArea(shape: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msGEOSLength(shape: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msGEOSDistance(shape1: *mut shapeObj, shape2: *mut shapeObj) -> f64;
}
extern "C" {
    pub fn msGenerateEncryptionKey(k: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msReadEncryptionKeyFromFile(
        keyfile: *const ::std::os::raw::c_char,
        k: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msEncryptStringWithKey(
        key: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msDecryptStringWithKey(
        key: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn msDecryptStringTokens(
        map: *mut mapObj,
        in_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msHexEncode(
        in_: *const ::std::os::raw::c_uchar,
        out: *mut ::std::os::raw::c_char,
        numbytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn msHexDecode(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_uchar,
        numchars: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msXmpPresent(map: *mut mapObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msXmpWrite(
        map: *mut mapObj,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msDrawTransformedShape(
        map: *mut mapObj,
        image: *mut imageObj,
        shape: *mut shapeObj,
        style: *mut styleObj,
        scalefactor: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msStyleSetGeomTransform(s: *mut styleObj, transform: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn msStyleGetGeomTransform(style: *mut styleObj) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn msGeomTransformShape(
        map: *mut mapObj,
        layer: *mut layerObj,
        shape: *mut shapeObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msGraticuleLayerGetIntersectionPoints(
        map: *mut mapObj,
        layer: *mut layerObj,
    ) -> *mut graticuleIntersectionObj;
}
extern "C" {
    pub fn msGraticuleLayerFreeIntersectionPoints(psValue: *mut graticuleIntersectionObj);
}
extern "C" {
    pub fn msSmoothShapeSIA(
        shape: *mut shapeObj,
        ss: ::std::os::raw::c_int,
        si: ::std::os::raw::c_int,
        preprocessing: *mut ::std::os::raw::c_char,
    ) -> *mut shapeObj;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strokeStyleObj {
    pub width: f64,
    pub patternlength: ::std::os::raw::c_int,
    pub pattern: [f64; 10usize],
    pub patternoffset: f64,
    pub color: *mut colorObj,
    pub linecap: ::std::os::raw::c_int,
    pub linejoin: ::std::os::raw::c_int,
    pub linejoinmaxsize: f64,
    pub antialiased: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_strokeStyleObj() {
    assert_eq!(
        ::std::mem::size_of::<strokeStyleObj>(),
        136usize,
        concat!("Size of: ", stringify!(strokeStyleObj))
    );
    assert_eq!(
        ::std::mem::align_of::<strokeStyleObj>(),
        8usize,
        concat!("Alignment of ", stringify!(strokeStyleObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).patternlength as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(patternlength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).pattern as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).patternoffset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(patternoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).color as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).linecap as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(linecap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).linejoin as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(linejoin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).linejoinmaxsize as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(linejoinmaxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<strokeStyleObj>())).antialiased as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(strokeStyleObj),
            "::",
            stringify!(antialiased)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct symbolStyleObj {
    pub color: *mut colorObj,
    pub backgroundcolor: *mut colorObj,
    pub outlinewidth: f64,
    pub outlinecolor: *mut colorObj,
    pub scale: f64,
    pub rotation: f64,
    pub gap: f64,
    pub style: *mut styleObj,
}
#[test]
fn bindgen_test_layout_symbolStyleObj() {
    assert_eq!(
        ::std::mem::size_of::<symbolStyleObj>(),
        64usize,
        concat!("Size of: ", stringify!(symbolStyleObj))
    );
    assert_eq!(
        ::std::mem::align_of::<symbolStyleObj>(),
        8usize,
        concat!("Alignment of ", stringify!(symbolStyleObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).backgroundcolor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(backgroundcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).outlinewidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(outlinewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).outlinecolor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).scale as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).rotation as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).gap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<symbolStyleObj>())).style as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(symbolStyleObj),
            "::",
            stringify!(style)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tileCacheObj {
    pub symbol: *mut symbolObj,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub color: colorObj,
    pub outlinecolor: colorObj,
    pub backgroundcolor: colorObj,
    pub outlinewidth: f64,
    pub rotation: f64,
    pub scale: f64,
    pub image: *mut imageObj,
    pub next: *mut tileCacheObj,
}
#[test]
fn bindgen_test_layout_tileCacheObj() {
    assert_eq!(
        ::std::mem::size_of::<tileCacheObj>(),
        104usize,
        concat!("Size of: ", stringify!(tileCacheObj))
    );
    assert_eq!(
        ::std::mem::align_of::<tileCacheObj>(),
        8usize,
        concat!("Alignment of ", stringify!(tileCacheObj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).color as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).outlinecolor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(outlinecolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).backgroundcolor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(backgroundcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).outlinewidth as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(outlinewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).rotation as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).scale as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).image as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tileCacheObj>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tileCacheObj),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn msInitializeDummyRenderer(vtable: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msInitializeRendererVTable(outputformat: *mut outputFormatObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableCairoRaster(
        renderer: *mut rendererVTableObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableCairoSVG(
        renderer: *mut rendererVTableObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableCairoPDF(
        renderer: *mut rendererVTableObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableOGL(renderer: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableAGG(renderer: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableUTFGrid(
        renderer: *mut rendererVTableObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableKML(renderer: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableOGR(renderer: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msPopulateRendererVTableMVT(renderer: *mut rendererVTableObj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msMVTWriteTile(
        map: *mut mapObj,
        sendheaders: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msCairoCleanup();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _autobuffer {
    pub data: *mut ::std::os::raw::c_uchar,
    pub size: size_t,
    pub available: size_t,
    pub _next_allocation_size: size_t,
}
#[test]
fn bindgen_test_layout__autobuffer() {
    assert_eq!(
        ::std::mem::size_of::<_autobuffer>(),
        32usize,
        concat!("Size of: ", stringify!(_autobuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_autobuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_autobuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_autobuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_autobuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_autobuffer>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_autobuffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_autobuffer>())).available as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_autobuffer),
            "::",
            stringify!(available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_autobuffer>()))._next_allocation_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_autobuffer),
            "::",
            stringify!(_next_allocation_size)
        )
    );
}
pub type bufferObj = _autobuffer;
extern "C" {
    pub fn msQuantizeRasterBuffer(
        rb: *mut rasterBufferObj,
        reqcolors: *mut ::std::os::raw::c_uint,
        palette: *mut rgbaPixel,
        forced_palette: *mut rgbaPixel,
        num_forced_palette_entries: ::std::os::raw::c_int,
        palette_scaling_maxval: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msClassifyRasterBuffer(
        rb: *mut rasterBufferObj,
        qrb: *mut rasterBufferObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSaveRasterBuffer(
        map: *mut mapObj,
        data: *mut rasterBufferObj,
        stream: *mut FILE,
        format: *mut outputFormatObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msSaveRasterBufferToBuffer(
        data: *mut rasterBufferObj,
        buffer: *mut bufferObj,
        format: *mut outputFormatObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msLoadMSRasterBufferFromFile(
        path: *mut ::std::os::raw::c_char,
        rb: *mut rasterBufferObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msApplyBlurringCompositingFilter(
        rb: *mut rasterBufferObj,
        radius: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn msApplyCompositingFilter(
        map: *mut mapObj,
        rb: *mut rasterBufferObj,
        filter: *mut CompositingFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msBufferInit(buffer: *mut bufferObj);
}
extern "C" {
    pub fn msBufferResize(buffer: *mut bufferObj, target_size: size_t);
}
extern "C" {
    pub fn msBufferFree(buffer: *mut bufferObj);
}
extern "C" {
    pub fn msBufferAppend(
        buffer: *mut bufferObj,
        data: *mut ::std::os::raw::c_void,
        length: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rendererVTableObj {
    pub supports_pixel_buffer: ::std::os::raw::c_int,
    pub supports_clipping: ::std::os::raw::c_int,
    pub supports_svg: ::std::os::raw::c_int,
    pub use_imagecache: ::std::os::raw::c_int,
    pub default_transform_mode: MS_TRANSFORM_MODE,
    pub transform_mode: MS_TRANSFORM_MODE,
    pub default_approximation_scale: f64,
    pub approximation_scale: f64,
    pub renderer_data: *mut ::std::os::raw::c_void,
    pub renderLine: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            p: *mut shapeObj,
            style: *mut strokeStyleObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderPolygon: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            p: *mut shapeObj,
            color: *mut colorObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderPolygonTiled: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            p: *mut shapeObj,
            tile: *mut imageObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderLineTiled: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            p: *mut shapeObj,
            tile: *mut imageObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderGlyphs: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            ts: *const textSymbolObj,
            clr: *mut colorObj,
            olcolor: *mut colorObj,
            olwidth: ::std::os::raw::c_int,
            isMarker: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderVectorSymbol: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            x: f64,
            y: f64,
            symbol: *mut symbolObj,
            style: *mut symbolStyleObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderPixmapSymbol: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            x: f64,
            y: f64,
            symbol: *mut symbolObj,
            style: *mut symbolStyleObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderEllipseSymbol: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut imageObj,
            x: f64,
            y: f64,
            symbol: *mut symbolObj,
            style: *mut symbolStyleObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderSVGSymbol: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            x: f64,
            y: f64,
            symbol: *mut symbolObj,
            style: *mut symbolStyleObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub renderTile: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            tile: *mut imageObj,
            x: f64,
            y: f64,
        ) -> ::std::os::raw::c_int,
    >,
    pub loadImageFromFile: ::std::option::Option<
        unsafe extern "C" fn(
            path: *mut ::std::os::raw::c_char,
            rb: *mut rasterBufferObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub getRasterBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(img: *mut imageObj, rb: *mut rasterBufferObj) -> ::std::os::raw::c_int,
    >,
    pub getRasterBufferCopy: ::std::option::Option<
        unsafe extern "C" fn(img: *mut imageObj, rb: *mut rasterBufferObj) -> ::std::os::raw::c_int,
    >,
    pub initializeRasterBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            rb: *mut rasterBufferObj,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            mode: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub mergeRasterBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            dest: *mut imageObj,
            overlay: *mut rasterBufferObj,
            opacity: f64,
            srcX: ::std::os::raw::c_int,
            srcY: ::std::os::raw::c_int,
            dstX: ::std::os::raw::c_int,
            dstY: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub compositeRasterBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            dest: *mut imageObj,
            overlay: *mut rasterBufferObj,
            comp_op: CompositingOperation,
            opacity: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub createImage: ::std::option::Option<
        unsafe extern "C" fn(
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            format: *mut outputFormatObj,
            bg: *mut colorObj,
        ) -> *mut imageObj,
    >,
    pub saveImage: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            map: *mut mapObj,
            fp: *mut FILE,
            format: *mut outputFormatObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub saveImageBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            size_ptr: *mut ::std::os::raw::c_int,
            format: *mut outputFormatObj,
        ) -> *mut ::std::os::raw::c_uchar,
    >,
    pub startLayer: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            map: *mut mapObj,
            layer: *mut layerObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub endLayer: ::std::option::Option<
        unsafe extern "C" fn(
            img: *mut imageObj,
            map: *mut mapObj,
            layer: *mut layerObj,
        ) -> ::std::os::raw::c_int,
    >,
    pub startShape: ::std::option::Option<
        unsafe extern "C" fn(img: *mut imageObj, shape: *mut shapeObj) -> ::std::os::raw::c_int,
    >,
    pub endShape: ::std::option::Option<
        unsafe extern "C" fn(img: *mut imageObj, shape: *mut shapeObj) -> ::std::os::raw::c_int,
    >,
    pub setClip: ::std::option::Option<
        unsafe extern "C" fn(img: *mut imageObj, clipRect: rectObj) -> ::std::os::raw::c_int,
    >,
    pub resetClip:
        ::std::option::Option<unsafe extern "C" fn(img: *mut imageObj) -> ::std::os::raw::c_int>,
    pub freeImage:
        ::std::option::Option<unsafe extern "C" fn(image: *mut imageObj) -> ::std::os::raw::c_int>,
    pub freeSymbol: ::std::option::Option<
        unsafe extern "C" fn(symbol: *mut symbolObj) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(renderer_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_rendererVTableObj() {
    assert_eq!(
        ::std::mem::size_of::<rendererVTableObj>(),
        272usize,
        concat!("Size of: ", stringify!(rendererVTableObj))
    );
    assert_eq!(
        ::std::mem::align_of::<rendererVTableObj>(),
        8usize,
        concat!("Alignment of ", stringify!(rendererVTableObj))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).supports_pixel_buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(supports_pixel_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).supports_clipping as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(supports_clipping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).supports_svg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(supports_svg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).use_imagecache as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(use_imagecache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).default_transform_mode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(default_transform_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).transform_mode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(transform_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).default_approximation_scale as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(default_approximation_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).approximation_scale as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(approximation_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).renderer_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderer_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).renderLine as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).renderPolygon as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderPolygon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderPolygonTiled as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderPolygonTiled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderLineTiled as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderLineTiled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).renderGlyphs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderGlyphs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderVectorSymbol as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderVectorSymbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderPixmapSymbol as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderPixmapSymbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderEllipseSymbol as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderEllipseSymbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).renderSVGSymbol as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderSVGSymbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).renderTile as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(renderTile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).loadImageFromFile as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(loadImageFromFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).getRasterBufferHandle as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(getRasterBufferHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).getRasterBufferCopy as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(getRasterBufferCopy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).initializeRasterBuffer as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(initializeRasterBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).mergeRasterBuffer as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(mergeRasterBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).compositeRasterBuffer as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(compositeRasterBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).createImage as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(createImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).saveImage as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(saveImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rendererVTableObj>())).saveImageBuffer as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(saveImageBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).startLayer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(startLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).endLayer as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(endLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).startShape as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(startShape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).endShape as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(endShape)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).setClip as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(setClip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).resetClip as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(resetClip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).freeImage as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(freeImage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).freeSymbol as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(freeSymbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rendererVTableObj>())).cleanup as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rendererVTableObj),
            "::",
            stringify!(cleanup)
        )
    );
}
extern "C" {
    pub fn msRenderRasterizedSVGSymbol(
        img: *mut imageObj,
        x: f64,
        y: f64,
        symbol: *mut symbolObj,
        style: *mut symbolStyleObj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msOffsetCurve(p: *mut shapeObj, offset: f64) -> *mut shapeObj;
}
extern "C" {
    pub fn msOGRSupportsIsNull(layer: *mut layerObj) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
